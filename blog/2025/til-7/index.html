<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="author" content="Yuxiang Qiu"> <title>TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline | Yuxiang Qiu</title> <meta name="generator" content="Jekyll v4.4.1"> <meta property="og:title" content="TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline"> <meta property="og:locale" content="en"> <meta name="description" content="Structured Generation"> <meta property="og:description" content="Structured Generation"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2025/til-7/"> <meta property="og:url" content="https://yuxqiu.github.io/blog/2025/til-7/"> <meta property="og:site_name" content="Yuxiang Qiu"> <meta property="og:image" content="https://yuxqiu.github.io/assets/img/og/posts/til-7.png"> <meta property="og:image:height" content="600"> <meta property="og:image:width" content="1200"> <meta property="og:image:alt" content="TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2025-02-16T22:29:42+00:00"> <meta name="twitter:card" content="summary_large_image"> <meta property="twitter:image" content="https://yuxqiu.github.io/assets/img/og/posts/til-7.png"> <meta name="twitter:image:alt" content="TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline"> <meta property="twitter:title" content="TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline"> <meta name="twitter:site" content="@yuxqiu"> <meta name="google-site-verification" content="OyP7PF7v8xjEbPqbdYaMosljunIcAOjdw_C6-TtA8f0"> <meta name="msvalidate.01" content="231286930EDC7A744F88D1D05B1BD04A"> <script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-03-05T10:41:18+00:00","datePublished":"2025-02-16T22:29:42+00:00","description":"Structured Generation","headline":"TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline","image":{"width":1200,"height":600,"alt":"TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline","url":"https://yuxqiu.github.io/assets/img/og/posts/til-7.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuxqiu.github.io/blog/2025/til-7/"},"url":"https://yuxqiu.github.io/blog/2025/til-7/"}</script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="/assets/fonts/google_fonts/google-fonts.css?dbb2a66cded10d969147626a2855d8a0"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2025/til-7/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/katex-override.css?4e0c6c5e17b36246ad64ca0f871ddbad"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuxiang Qiu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <svg id="light-toggle-system" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg> <svg id="light-toggle-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 1.992a10 10 0 1 0 9.236 13.838c.341 -.82 -.476 -1.644 -1.298 -1.31a6.5 6.5 0 0 1 -6.864 -10.787l.077 -.08c.551 -.63 .113 -1.653 -.758 -1.653h-.266l-.068 -.006l-.06 -.002z"></path></svg> <svg id="light-toggle-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path></svg> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">TIL: Structured Generation, RAG, Backdoor LLMs, Eytzinger Binary Search, Trampoline</h1> <p class="post-meta"> Created in February 16, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> 2025 </a>   ·   <a href="/blog/tag/til"> # TIL</a>   <a href="/blog/tag/llm"> # LLM</a>   <a href="/blog/tag/algorithm"> # Algorithm</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#structured-generation">Structured Generation</a></li> <li class="toc-entry toc-h2"><a href="#rag">RAG</a></li> <li class="toc-entry toc-h2"><a href="#backdoor-large-language-models">Backdoor Large Language Models</a></li> <li class="toc-entry toc-h2"> <a href="#eytzinger-binary-search">Eytzinger Binary Search</a> <ul> <li class="toc-entry toc-h3"><a href="#eytzinger">Eytzinger</a></li> <li class="toc-entry toc-h3"><a href="#implementing-bst">Implementing BST</a></li> <li class="toc-entry toc-h3"><a href="#prefetching">Prefetching</a></li> <li class="toc-entry toc-h3"><a href="#is-it-really-faster">Is it really faster?</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#on-recursion-continuations-and-trampolines">On Recursion, Continuations and Trampolines</a></li> <li class="toc-entry toc-h2"><a href="#others">Others</a></li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="structured-generation">Structured Generation</h2> <ul> <li><a href="https://mattrickard.com/rellm" rel="external nofollow noopener" target="_blank">ReLLM: Exact Structure for Large Language Model Completions</a></li> <li><a href="https://mattrickard.com/context-free-grammar-parsing-with-llms" rel="external nofollow noopener" target="_blank">Context-Free Grammar Parsing with LLMs</a></li> </ul> <p>It turns out structured generation is not that hard. Previously, I thought LLM was only fine-tuned to perform better on structured generation. But it turns out suppressing incorrect logics is also a good idea.</p> <ul> <li>That’s how you can force LLM to generate strings matching regular expression.</li> <li>On top of that, you can enforce LLMs to follow some CFG. Might actually be useful in code generation tasks, where CFG is clearly defined. <ul> <li>It reminds me sometimes ChatGPT generated some ill-formed latex formulas that even their parser cannot recognize.</li> </ul> </li> </ul> <h2 id="rag">RAG</h2> <ul> <li><a href="https://codeawake.com/blog/rag-from-scratch" rel="external nofollow noopener" target="_blank">Retrieval Augmented Generation from Scratch: Inception RAG</a></li> <li><a href="https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/" rel="external nofollow noopener" target="_blank">GraphRAG: Unlocking LLM discovery on narrative private data</a></li> <li><a href="https://medium.com/neo4j/enhancing-the-accuracy-of-rag-applications-with-knowledge-graphs-ad5e2ffab663" rel="external nofollow noopener" target="_blank">Enhancing the Accuracy of RAG Applications With Knowledge Graphs</a></li> </ul> <p>Simple RAG is just a combination of <em>embedding</em> + <em>vector database</em> + <em>nearest neighbor search</em> + <em>context</em> (based on some pre-defined similarity metric, which is usually cosine similarity).</p> <ul> <li>Works well for unstructured data.</li> <li>How to do chunking? Fixed-size, hierarchical, account document format, semantic.</li> <li>No big picture: cannot capture relation and overall themes.</li> <li>How to do it fast: approximate nearest neighbor.</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/2025/02/rag-chunking-480.webp 480w,/assets/img/blog/2025/02/rag-chunking-800.webp 800w,/assets/img/blog/2025/02/rag-chunking-1400.webp 1400w," sizes="(max-width: 600px) 100vw, (max-width: 1200px) 80vw, 50vw" type="image/webp"></source> <img src="/assets/img/blog/2025/02/rag-chunking.png" width="100%" height="auto" alt="rag-chunking-strategy" loading="lazy"> </picture> </figure> <p>Graph RAG mitigates some of the issues mentioned above.</p> <ul> <li>Knowledge graph captures the entities + relationships. <ul> <li>How to build the graph? AI can help, but what are entities/relationships that we need to capture?</li> <li>How can this scale? Can it replace search engine?</li> </ul> </li> <li>Graph search is even more tricky? What’s the granularity (how many entities/neighbors we need to find) of graph search?</li> <li>Of course, this can be combined with simple RAG above.</li> </ul> <p>History</p> <ul> <li>The easiest way to support continuous conversation: pass previous conversation as contextual info.</li> </ul> <p>Query Rewrite</p> <ul> <li>Rewrite the query based on history. Useful for solving questions that refer to information in context (e.g., pronoun - where is she from).</li> </ul> <h2 id="backdoor-large-language-models">Backdoor Large Language Models</h2> <ul> <li><a href="https://blog.sshh.io/p/how-to-backdoor-large-language-models" rel="external nofollow noopener" target="_blank">How to Backdoor Large Language Models</a></li> </ul> <p>Idea: backdoor the first decoder layer -&gt; such that the embedding of a benign system prompt is the same as that of a malicious system prompt.</p> <p>Surprisingly, with just a few samples, we can easily backdoor a LLM. To prevent this, SNARK might be a viable solution (possibly via <a href="https://dl.acm.org/doi/abs/10.1145/3658644.3670316" rel="external nofollow noopener" target="_blank">zkPoT</a> + some sort of commitment).</p> <h2 id="eytzinger-binary-search">Eytzinger Binary Search</h2> <ul> <li><a href="https://algorithmica.org/en/eytzinger" rel="external nofollow noopener" target="_blank">Eytzinger Binary Search</a></li> </ul> <p>Good idea (cache-friendly), but the article has some mistakes and unclear points.</p> <h3 id="eytzinger">Eytzinger</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">eytzinger</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">eytzinger</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">eytzinger</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>To understand why this works, think about what we want to achieve: turning a sorted array into a BST (in array form).</p> <p>To do so, we need to have a mapping between the index of the original array and the “index” of the BST.</p> <p>This might remind you about in-order tree traversal. Traverse BST in-order gives us a sorted array. So, what we need to do here is to traverse in-order the empty BST. During traversal, instead of utilizing the value of the node, we assign values to it. This is essentially what the algorithm does.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">eytzinger(i, 2 * k)</code>: traverse the left subtree.</li> <li> <code class="language-plaintext highlighter-rouge">b[k] = a[i++]</code>: value is assigned to the BST.</li> <li> <code class="language-plaintext highlighter-rouge">eytzinger(i, 2 * k + 1)</code>: traverse the right subtree.</li> </ul> <p>The index <code class="language-plaintext highlighter-rouge">i</code> here is simply to record which element of a is waiting to be used.</p> <p>Later, the author gave an incorrect example:</p> <blockquote> <p>Binary search implementation</p> <p>…</p> <p>The only problem arises when we need to restore the index of the resulting element, as may end up not pointing to a leaf node. Here is an example of how that can happen:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>array:      1 2 3 4 5 6 7 8
eytzinger:  4 2 5 1 6 3 7 8
1st range:  ---------------  k := 1
2nd range:  -------          k := 2*k      (=2)
3rd range:      ---          k := 2*k + 1  (=5)
4th range:        -          k := 2*k + 1  (=11)
</code></pre></div> </div> </blockquote> <ul> <li>Here, the eytzinger array is simply wrong. It’s easy to see that at index 5 (1-indexed), the element is 6, breaking the invariant of the BST (as 6 is in the left subtree but &gt; the root node 4).</li> <li>Correct array: <code class="language-plaintext highlighter-rouge">5 3 7 2 4 6 8 1</code> </li> </ul> <h3 id="implementing-bst">Implementing BST</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">__builtin_ffs</span><span class="p">(</span><span class="o">~</span><span class="n">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>Note that, unless the answer is the last element of the array, we compare x against it at some point, and after we learn that it is not less than x, we start comparing against elements to the left, and all these comparisons will evaluate true (i. e. leading to the right). Hence, the solution to restoring the resulting element is to cancel some number of right turns.</p> </blockquote> <p>This is confusing, at least for me. But, here, what the author tries to express is, we need to revert the effect of last left turn. This is because before the left turn, we have the smallest element v that is &gt; x.</p> <ul> <li>There is no smaller element because if such element exists, think about what would happen to their first common ancestor?</li> </ul> <p>So, what we want is to revert to the element where the last turn left happens.</p> <ul> <li>&lt;=&gt; find the first 0, from LSB, of a number ended with many 1s.</li> <li>&lt;=&gt; find the first 1, from LSB, of ~number.</li> <li>&lt;=&gt; <code class="language-plaintext highlighter-rouge">__builtin_ffs(~k);</code> </li> </ul> <h3 id="prefetching">Prefetching</h3> <p>This is the coolest part of the article.</p> <blockquote> <p>Here, <code class="language-plaintext highlighter-rouge">block_size</code> equals 16, which is precisely how many ints are needed to cover a cache line. When we reference cache line at b + k * block_size, we are referencing k’s grand-grandson (block_size = 16, or 4 left turns) and possibly some of his neighbors in his layer (recall that indexes at the same level are just consecutive numbers).</p> <p>The whole point of doing this is that there is a good chance that we will prefetch an element that we will use later on (i+4)-th iteration. What chance, exactly? Well, it turns out that it is constant for each iteration.</p> </blockquote> <p>IMHO, the chance of using it is actually 1. Intuitively, think about any iteration i and index k, say <code class="language-plaintext highlighter-rouge">i=5</code> and <code class="language-plaintext highlighter-rouge">k=10101</code>. At this k, we will fetch 16 values starting from <code class="language-plaintext highlighter-rouge">b + 101010000</code>. Then, we know that at (i+4)-th iteration, this cache line will guaranteed to be used, because at that iteration, <code class="language-plaintext highlighter-rouge">101010000 &lt;= k' &lt;= 101011111</code>. Since each cache block has size 16, each possible <code class="language-plaintext highlighter-rouge">b[k']</code> value is loaded in the cache.</p> <ul> <li>I made one simplification: <code class="language-plaintext highlighter-rouge">b</code> is 64-bytes aligned.</li> <li>As pointed out in the <a href="https://arxiv.org/pdf/1509.05053" rel="external nofollow noopener" target="_blank">paper</a>, prefetching is crucial to ensure high performance on large array. It seems that branch predictor is actually good at predicting this, therefore making the branchy implementation faster than the branchless version (without prefetching) for large array.</li> </ul> <h3 id="is-it-really-faster">Is it really faster?</h3> <p>Be aware that conversion to Eytzinger is not free. So, IMO, this search is more suited to an unsorted array of data as to perform binary search on this, we need to</p> <ul> <li>sort the array (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>) -&gt; binary search (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>).</li> </ul> <p>In this case, adding an additional step in-between to convert the sorted array to Eytzinger (or simply sorting the array using Eytzinger) is acceptable as sorting takes most of the time.</p> <h2 id="on-recursion-continuations-and-trampolines">On Recursion, Continuations and Trampolines</h2> <ul> <li><a href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/" rel="external nofollow noopener" target="_blank">On Recursion, Continuations and Trampolines</a></li> </ul> <p>I am not very confident in every detail. But the following is interesting</p> <ul> <li>Continuations and CPS: reminds me of the good old Haskell time.</li> <li>Synthesizing tail calls with CPS-transform <ul> <li>The step 4 in the conversion process is indeed not very intuitive.</li> <li>But, in my understanding, the goal of converting to CPS is to ensure we can start from the bottom of the recursion (the base case) and gradually build up (like playing with building bricks) till the final <code class="language-plaintext highlighter-rouge">cont</code> (which is usually <code class="language-plaintext highlighter-rouge">id</code>).</li> </ul> </li> <li>Trampoline is very interesting. Code is worth a thousand words: <ul> <li> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">trampoline</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">while</span> <span class="nf">callable</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nf">v</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">v</span>
</code></pre></div> </div> </li> <li>It essentially ensures we evaluate one function at a time, iteratively.</li> </ul> </li> </ul> <p>A quick observation: the state captured by the returned function is gradually increasing, proportional to the number of tail recursions that we need to do originally. If the returned function is stored in the stack, the stack will still be eventually blown up. If it’s in the heap, this method is arguably far from ideal, in cases that we can do tail call elimination. But as the author mentioned:</p> <blockquote> <p>Alternatively you may see TRE (Tail Recursion Elimination). <strong>TCO is more general</strong> because tail calls don’t necessarily have to be directly recursive (as the <code class="language-plaintext highlighter-rouge">is_even</code> / <code class="language-plaintext highlighter-rouge">is_odd</code> example demonstrates).</p> </blockquote> <h2 id="others">Others</h2> <ul> <li> <a href="https://chadnauseam.com/coding/random/calculator-app" rel="external nofollow noopener" target="_blank">“A calculator app? Anyone could make that.”</a>: Fascinating to read! What’s behind a simple calculator? - “recursive real arithmetic” (RRA).</li> <li> <a href="https://benhoyt.com/writings/gogit/" rel="external nofollow noopener" target="_blank">Scripting with Go: a 400-line Git client that can create a repo and push itself to GitHub</a>: Bookmarked a long time ago. Thought it was about git. But it’s more about go.</li> </ul> </div> </article> </div> </div> <footer class="sticky-bottom" role="contentinfo"> <div class="caption post-version"> © 2025 <a href="/">Yuxiang Qiu</a> <br> v25-03-05 | <a href="https://github.com/yuxqiu/yuxqiu.github.io/commit/8210e3b0c38cd4a8557f5a4a5e2ec44efce8b4d8" rel="external nofollow noopener" target="_blank">8210e3b</a> </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> </body> </html>