<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Non-Interactivity and Graph Non-Isomorphism | Yuxiang Qiu </title> <meta name="author" content="Yuxiang Qiu"> <meta name="description" content="Yuxiang Qiu"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="/assets/fonts/google_fonts/google-fonts.css?dbb2a66cded10d969147626a2855d8a0"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2024/zkp-lec-1/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuxiang Qiu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <svg id="light-toggle-system" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg> <svg id="light-toggle-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 1.992a10 10 0 1 0 9.236 13.838c.341 -.82 -.476 -1.644 -1.298 -1.31a6.5 6.5 0 0 1 -6.864 -10.787l.077 -.08c.551 -.63 .113 -1.653 -.758 -1.653h-.266l-.068 -.006l-.06 -.002z"></path></svg> <svg id="light-toggle-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path></svg> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Non-Interactivity and Graph Non-Isomorphism</h1> <p class="post-meta"> Created in September 10, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> 2024 </a>   ·   <a href="/blog/tag/zkp"> # ZKP</a>   <a href="/blog/tag/applied-cryptography"> # Applied Cryptography</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#not-all-interactive-protocols-can-be-converted-to-non-interactive-protocols">Not all interactive protocols can be converted to non-interactive protocols</a> <ul> <li class="toc-entry toc-h3"><a href="#schnorrs-protocol">Schnorr’s Protocol</a></li> <li class="toc-entry toc-h3"><a href="#what-prevents-grinding">What prevents grinding?</a></li> <li class="toc-entry toc-h3"><a href="#why-cant-all-interactive-protocols-be-converted-to-non-interactive-protocols-via-arthur-merlin-game">Why can’t all interactive protocols be converted to non-interactive protocols (via Arthur-Merlin Game)?</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#graph-non-isomorphism">Graph Non-Isomorphism</a> <ul> <li class="toc-entry toc-h3"><a href="#solution-1">Solution 1</a></li> <li class="toc-entry toc-h3"><a href="#solution-2">Solution 2</a></li> <li class="toc-entry toc-h3"><a href="#last-solution">Last Solution</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>This is a supplement to <a href="https://www.youtube.com/watch?v=uchjTIlPzFo" rel="external nofollow noopener" target="_blank">Zero Knowledge Proofs - Lecture 1</a>.</p> <h2 id="not-all-interactive-protocols-can-be-converted-to-non-interactive-protocols">Not all interactive protocols can be converted to non-interactive protocols</h2> <p>In the lecture, the professor claimed that not all interactive protocols can be converted to non-interactive protocols, and the reason given in the <a href="https://zk-learning.org/assets/Lecture1-2023-slides.pdf?slide=72" rel="external nofollow noopener" target="_blank">slide</a> was that IP = AM sometimes requires a super-polynomial prover, and in the case of Fiat-Shamir transformation, the prover needs to be computationally bounded, and therefore cannot invert H.</p> <p>However, why is this the case? Let’s use Schnorr’s Protocol as a case study to explain it.</p> <h3 id="schnorrs-protocol">Schnorr’s Protocol</h3> <p>Goal: Prover convinces Verifier that they know <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span> such that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msup><mi>g</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">h = g^x</annotation></semantics></math></span> where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span> is a generator of a group.</p> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Prover</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Verifier</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>r</mi><mrow><mtext>  </mtext><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mi mathvariant="normal">$</mi></mpadded></mover><mtext>  </mtext></mrow><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mo>∗</mo></msubsup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><mo>=</mo><msup><mi>g</mi><mi>r</mi></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mpadded width="0px"><mphantom></mphantom></mpadded><mpadded height="0px" depth="0px"><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mspace width="2.8453em"></mspace><mi>u</mi><mspace width="2.8453em"></mspace></mrow></mpadded></mover></mpadded></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mrow><mtext>  </mtext><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mi mathvariant="normal">$</mi></mpadded></mover><mtext>  </mtext></mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mpadded width="0px"><mphantom></mphantom></mpadded><mpadded height="0px" depth="0px"><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mspace width="2.8453em"></mspace><mi>c</mi><mspace width="2.8453em"></mspace></mrow></mpadded></mover></mpadded></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>z</mi><mo>=</mo><mi>r</mi><mo>+</mo><mi>x</mi><mo>⋅</mo><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mpadded width="0px"><mphantom></mphantom></mpadded><mpadded height="0px" depth="0px"><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mspace width="2.8453em"></mspace><mi>z</mi><mspace width="2.8453em"></mspace></mrow></mpadded></mover></mpadded></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>g</mi><mi>z</mi></msup><mo><mover><mo><mo>=</mo></mo><mo stretchy="false" lspace="0em" rspace="0em">?</mo></mover></mo><mi>u</mi><mo>⋅</mo><msup><mi>h</mi><mi>c</mi></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\newcommand{\work}[2]{#1 &amp; &amp; #2\\} \newcommand{\varprover}{\text{Prover}} \newcommand{\varverifier}{\text{Verifier}} \newcommand{\alicework}[1]{#1 &amp; &amp;\\[-5pt]} \newcommand{\samplezqs}[1]{#1\sampleSymb\zqs} \newcommand{\varr}{r} \newcommand{\sampleSymb}{ {\; \xleftarrow{\$} \;} } \newcommand{\zqs}{\mathbb{Z}_q^\ast} \newcommand{\varu}{u} \newcommand{\varg}{g} \newcommand{\alicebob}[3]{#1 &amp; \ra{#2} &amp; #3\\[-5pt]} \newcommand{\ra}[1]{\vphantom{}\smash{\xrightarrow{\hspace{1cm}#1\hspace{1cm}}}} \newcommand{\bobwork}[1]{ &amp; &amp; #1\\[-5pt]} \newcommand{\schnorrvalidate}{\mathsf{schnorr}\_\mathsf{validate}} \newcommand{\varh}{h} \newcommand{\bobseparator}{&amp;&amp;-------\\} \newcommand{\sample}[1]{#1\sampleSymb\zq} \newcommand{\varc}{c} \newcommand{\bobalice}[3]{#1 &amp; \la{#2} &amp; #3\\[-5pt]} \newcommand{\la}[1]{\vphantom{}\smash{\xleftarrow{\hspace{1cm}#1\hspace{1cm}}}} \newcommand{\varx}{x} \newcommand{\varz}{z} \newcommand{\equalQ}{\overset{?}{=}} \newcommand{\zq}{\mathbb{Z}_\varq} \newcommand{\varq}{q} \begin{array}{c} \work{\varprover}{\varverifier} \alicework{\samplezqs{\varr}} \alicework{\varu = \varg^\varr} \alicebob{}{\varu}{} \bobwork{\sample{\varc}} \bobalice{}{\varc}{} \alicework{\varz = \varr + \varx\cdot \varc} \alicebob{}{\varz}{} \bobwork{\varg^{\varz} \equalQ \varu \cdot \varh^\varc } \end{array}</annotation></semantics></math></span> <ul> <li>Thanks <a href="https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/schnorr/" rel="external nofollow noopener" target="_blank">ZKDocs - Schnorr’s identification protocol</a> and <a href="https://crypto.stanford.edu/cs355/19sp/lec5.pdf" rel="external nofollow noopener" target="_blank">Lecture 5: Proofs of Knowledge, Schnorr’s protocol, NIZK</a> for providing the code and the graph.</li> </ul> <p>The completeness of the above protocol is easy to see. For soundness, instead of proving statistical soundness, we can prove <a href="https://crypto.stanford.edu/cs355/19sp/lec5.pdf?slide=3" rel="external nofollow noopener" target="_blank">special soundness</a>.</p> <p>Just a sidenote, to convert this Schnorr’s Protocol to an non-interactive version, <a href="https://www.zkdocs.com/docs/zkdocs/protocol-primitives/fiat-shamir/#what-can-go-wrong" rel="external nofollow noopener" target="_blank">ZKDocs</a> provides a case where incorrect input is used in Fiat-Shamir transformation, which causes the protocol to be insecure. It’s worth noting that the case they discussed is a bit different from what I have shown above. It’s about generating a valid triple (<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>g</mi><mi>x</mi></msup><mspace></mspace><mspace width="0.4444em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X=g^x \pmod q</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mtext>Hash(input)</mtext></mrow><annotation encoding="application/x-tex">c = \text{Hash(input)}</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span>) for any X of prover’s choice <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, which means there is no fixed <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span> shared by both parties at the beginning. If you are interested, feel free to read the linked article and the paper.</p> <h3 id="what-prevents-grinding">What prevents grinding?</h3> <p>Now, let’s get back to the protocol that I described above. Suppose we want to turn it into an non-interactive version. The obvious thing we can do is to let <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mtext>Hash(u)</mtext></mrow><annotation encoding="application/x-tex">c = \text{Hash(u)}</annotation></semantics></math></span> and then use it to generate <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>r</mi><mo>+</mo><mi>x</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">z = r + x * c</annotation></semantics></math></span>.</p> <p>Now, you might be thinking: what prevents a malicious prover from grinding? In other words, since the variable <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span> is just a coin <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, the malicious prover can just sampled 2 <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span> and it’s very likely that one of the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Hash</mtext><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>Hash</mtext><mo stretchy="false">(</mo><msup><mi>g</mi><mi>r</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Hash}(u) = \text{Hash}(g^r)</annotation></semantics></math></span> it gets is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span>, which means it can then return <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">z = r</annotation></semantics></math></span> directly. From the perspective of the verifier, this is a correct proof.</p> <p>The answer to that problem is also very simple: c is not a coin, but a random value drawn from a field. If this is the case, the challenge space <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span> (the field where the “coin” c is chosen from) will be pretty large. As a result, the probability of finding the collision that I described above will be <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∥</mi><mi>C</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\|C\|}</annotation></semantics></math></span> <sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.</p> <ul> <li>If you treat <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span> as a <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>-bit number, then the probability will be <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∥</mi><msup><mn>2</mn><mi>c</mi></msup><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\|2^c\|}</annotation></semantics></math></span>.</li> </ul> <h3 id="why-cant-all-interactive-protocols-be-converted-to-non-interactive-protocols-via-arthur-merlin-game">Why can’t all interactive protocols be converted to non-interactive protocols (via Arthur-Merlin Game)?</h3> <p>By the analysis above, we know that the probability of successfully grinding is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mi>c</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^c}</annotation></semantics></math></span>. If the prover is computationally bounded, this is fine. However, if it’s not the case, we are in trouble.</p> <p>This is exactly why not all interactive protocols can be converted to non-interactive protocols as IP = AM transformation sometimes requires extra <strong>super-polynomial</strong> powers from Merlin (the prover).</p> <h2 id="graph-non-isomorphism">Graph Non-Isomorphism</h2> <p>In the lecture, the professor shows an interactive proof of graph non-isomorphism. However, this proof is not ZK because <strong>a malicious verifier</strong> can use a completely new graph (not derived from either <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>) and ask prover to show whether it is isomorphism to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>. Therefore, it can obtain extra information that cannot be simulated.</p> <p>The way to solve this problem is briefly discussed: the verifier first prove to the prover that the graph it sends (let’s call it <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>) is indeed isomorphic to one of the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span> (can be both).</p> <ul> <li>But it is indeed very tricky to do so if you think about this carefully. How can you prove this without revealing which graph is isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>?</li> </ul> <p>The remaining part of this article will analyze <a href="https://pinkpurplepineapples.wordpress.com/2019/07/24/zero-knowledge-proofs-graph-isomorphism/" rel="external nofollow noopener" target="_blank">this amazing blog</a> to see how we can prove this in a PZK (perfect zero knowledge) way.</p> <h3 id="solution-1">Solution 1</h3> <blockquote> <p>Send the two graphs <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_0(G_0), \pi_1(G_1)</annotation></semantics></math></span>. The verifier then sends back an integer, pointing to one of these two graphs, and the prover responds by providing the permutation from <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> to this graph. Note that if at least one of the graphs is isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>, the prover can do so with at least probability 1/2.</p> </blockquote> <p>This does not work because a simulator <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span>, given access to verifier <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span>, cannot simulate this because</p> <ul> <li>It runs in PPT (probabilistic polynomial time), so it cannot using <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_0(G_0), \pi_1(G_1)</annotation></semantics></math></span> (where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0, \pi_1</annotation></semantics></math></span> are random permutations), generating a random number <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>, checking if it is able to find a permutation between <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">G_r</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>.</li> <li>At the same time, it does not know which graph <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> is isomorphic to, so it pre-prepare a permutation <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span> and generate messages like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(G), \pi_1(G_1)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_0(G_0), \pi(G)</annotation></semantics></math></span>.</li> </ul> <h3 id="solution-2">Solution 2</h3> <p>The prover sends back <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(G), \pi_0(G_0), \pi_1(G_1)</annotation></semantics></math></span> in a random order. The verifier then randomly points to one of the three graphs, and asks the prover to show that this graph is isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>.</p> <p>For the same reason, this method doesn’t work either. Given the length of the article, I’ll skip to the last solution.</p> <h3 id="last-solution">Last Solution</h3> <p>The last solution is a very interesting construction.</p> <blockquote> <ol> <li>Prover responds by sending two scrambled and permuted ordered copies of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span> to the Verifier, with an additional restriction that second scrambling of the three graphs is either a right shift, or a left shift of the original three graphs. <ul> <li>In other words, it sends: <ul> <li> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(H), \pi_0(H_0), \pi_1(H_1)</annotation></semantics></math></span> </li> <li> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>π</mi><mn>0</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msubsup><mi>π</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>π</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_0'(H_0), \pi_1'(H_1), \pi'(H)</annotation></semantics></math></span> </li> </ul> </li> </ul> <ul> <li>or: <ul> <li> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(H), \pi_0(H_0), \pi_1(H_1)</annotation></semantics></math></span> </li> <li> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>π</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>π</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msubsup><mi>π</mi><mn>0</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1'(H_1), \pi'(H), \pi_0'(H_0)</annotation></semantics></math></span> </li> </ul> </li> <li>where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo separator="true">,</mo><msub><mi>H</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>H</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">H, H_0, H_1</annotation></semantics></math></span> is some random permutation (<strong>ordering</strong>) of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G, G_0, G_1</annotation></semantics></math></span> </li> </ul> </li> <li>The Verifier now responds with either a 0, or a 1, one option to continue with the proof, and the other to verify that the two permuted copies indeed satisfy the requirements.</li> <li>If the Verifier sent a 0, the Prover reveals the two permutations, and we go back to step 2. If the Verifier sent a 1, we continue to prove that at least one of the graphs is isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>, by choosing one of the columns, and showing that both of the graphs in that column are isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> by sending back the permutations.</li> </ol> </blockquote> <p>This solution works and achieve PZK because:</p> <ul> <li>H0, H1, H2 is a permutation of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_2</annotation></semantics></math></span> (they are <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_2</annotation></semantics></math></span> in random order) -&gt; this ensures that the correct column that the prover will pick can be any of the three columns. <ul> <li>Suppose no permutation is used, and only left and right shifts are used. Then, the probability of a column being selected is 1:1:0 (G isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span>) or 1:0:1 (to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>) or 1:1:1 (to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>) depending on which graph <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> is isomorphic to. <ul> <li> <p>Isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span></p> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{G}, G_0, G_1</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mn mathvariant="bold">0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{G_0}, G_1, G</annotation></semantics></math></span> <ul> <li>or</li> </ul> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo separator="true">,</mo><msub><mi mathvariant="bold">G</mi><mn mathvariant="bold">0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G, \mathbf{G_0}, G_1</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="bold">G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_1, \mathbf{G}, G_0</annotation></semantics></math></span> </li> <li> <p>Isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span></p> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">G</mi><mn mathvariant="bold">1</mn></msub></mrow><annotation encoding="application/x-tex">G, G_0, \mathbf{G_1}</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="bold">G</mi></mrow><annotation encoding="application/x-tex">G_0, G_1, \mathbf{G}</annotation></semantics></math></span> <ul> <li>or</li> </ul> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{G}, G_0, G_1</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mn mathvariant="bold">1</mn></msub><mo separator="true">,</mo><mi>G</mi><mo separator="true">,</mo><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{G_1}, G, G_0</annotation></semantics></math></span> </li> <li> <p>So, without permutation, we can know some additional information based on which column is selected.</p> </li> </ul> </li> </ul> </li> <li>Left Shift or Right Shift: it’s important to have them as well. This ensures that no matter the permutation, the distance between the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span>/<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span> (the graph <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> is isomorphic to) is always 1. If the distance is not always the same, after randomly selecting the column in the simulator, we cannot construct the other two columns randomly because we must fix the position of the graph that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> is isomorphic to match distance = 1. <ul> <li>For example, given this permutation <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">G_x</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">G_y</annotation></semantics></math></span>. Suppose <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span> is isomorphic to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span>. If we only allow left shift, we can only choose <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">G_y</annotation></semantics></math></span> as the position for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span>. <ul> <li>But, in reality, the simulator doesn’t know which graph <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span> is isomorphic to.</li> <li>So, after selecting the column randomly, it cannot proceed.</li> </ul> </li> </ul> </li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p><a href="https://eprint.iacr.org/2016/771.pdf#page=6" rel="external nofollow noopener" target="_blank">https://eprint.iacr.org/2016/771.pdf#page=6</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2"> <p>This is not true, but a misconception that I had after listening to lecture 1. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p><a href="https://crypto.stackexchange.com/questions/97735/grinding-in-the-fiat-shamir-heuristic" rel="external nofollow noopener" target="_blank">https://crypto.stackexchange.com/questions/97735/grinding-in-the-fiat-shamir-heuristic</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?fd05ad563fc46d96dfe9e0820bab4b75" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> </body> </html>