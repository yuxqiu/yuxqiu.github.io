<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Implement a ThreadPool in C++ from Scratch | Yuxiang Qiu </title> <meta name="author" content="Yuxiang Qiu"> <meta name="description" content="Yuxiang Qiu"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="/assets/fonts/google_fonts/google-fonts.css?dbb2a66cded10d969147626a2855d8a0"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2023/threadpool/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuxiang Qiu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <svg id="light-toggle-system" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg> <svg id="light-toggle-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 1.992a10 10 0 1 0 9.236 13.838c.341 -.82 -.476 -1.644 -1.298 -1.31a6.5 6.5 0 0 1 -6.864 -10.787l.077 -.08c.551 -.63 .113 -1.653 -.758 -1.653h-.266l-.068 -.006l-.06 -.002z"></path></svg> <svg id="light-toggle-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path></svg> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Implement a ThreadPool in C++ from Scratch</h1> <p class="post-meta"> Created in January 13, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> 2023 </a>   ·   <a href="/blog/tag/cpp"> # cpp</a>   <a href="/blog/tag/concurrency"> # concurrency</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#prerequisite">Prerequisite</a></li> <li class="toc-entry toc-h2"><a href="#overview">Overview</a></li> <li class="toc-entry toc-h2"> <a href="#challenges">Challenges</a> <ul> <li class="toc-entry toc-h3"><a href="#get-return-type-of-a-callable">Get Return Type of a Callable</a></li> <li class="toc-entry toc-h3"><a href="#variadic-lambda">Variadic Lambda?</a></li> <li class="toc-entry toc-h3"><a href="#nolint">NOLINT</a></li> <li class="toc-entry toc-h3"><a href="#move-only-function">move-only-function</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#the-final-code">The final code</a></li> <li class="toc-entry toc-h2"><a href="#benchmark">Benchmark</a></li> <li class="toc-entry toc-h2"><a href="#improvements">Improvements</a></li> <li class="toc-entry toc-h2"><a href="#what-i-learned">What I learned</a></li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="prerequisite">Prerequisite</h2> <p>Before reading this article, make sure you have basic understandings of the following concepts:</p> <ol> <li> <code class="language-plaintext highlighter-rouge">std::thread</code>: how to create a thread, how to deal with a running thread, how the parameters are used in thread constructor</li> <li> <code class="language-plaintext highlighter-rouge">std::mutex</code>, <code class="language-plaintext highlighter-rouge">std::lock_guard</code>, <code class="language-plaintext highlighter-rouge">std::unique_lock</code>: the differences between those three and the benefits of the later two</li> <li> <code class="language-plaintext highlighter-rouge">std::condition_variable</code>:</li> <li> <code class="language-plaintext highlighter-rouge">std::future</code>, <code class="language-plaintext highlighter-rouge">std::promise</code>: the relation between a <code class="language-plaintext highlighter-rouge">future</code> and a <code class="language-plaintext highlighter-rouge">promise</code>, how to construct them, can they be copied/moved constructed/assigned, the mechanisms behind <code class="language-plaintext highlighter-rouge">std::future</code> and <code class="language-plaintext highlighter-rouge">std::promise</code> </li> <li> <code class="language-plaintext highlighter-rouge">std::function</code>: what is it, mechanisms of type erasure</li> <li> <code class="language-plaintext highlighter-rouge">std::move</code>, <code class="language-plaintext highlighter-rouge">std::forward</code>: move semantics, universal reference, perfect forwarding</li> <li>meta-programming: understand <code class="language-plaintext highlighter-rouge">if constexpr</code>, have basic ideas of type_traits</li> </ol> <h2 id="overview">Overview</h2> <p>Last night, I read an article in which a guy talked about how to implement a ThreadPool in C++. However, I wasn’t happy with his implementation because he used some unnecessary dynamic memory allocation: 1 for <code class="language-plaintext highlighter-rouge">package_task</code> with <code class="language-plaintext highlighter-rouge">shared_ptr</code>, 1 for the mechanisms behind <code class="language-plaintext highlighter-rouge">std::future</code> (unavoidable), 2 for a list of threads and a list of tasks (unavoidable), 1 for every <code class="language-plaintext highlighter-rouge">std::function</code> used (unavoidable) and etc. The one that I really want to get rid of is the allocation for <code class="language-plaintext highlighter-rouge">package_task</code>. Considering I have never made a thread pool in C++, I decide to write it today.</p> <p>So my goal for this thread pool is:</p> <ul> <li>use dynamic memory allocation as little as possible</li> <li>the supported version of C++ needs to be as low as possible (ideally C++11)</li> <li>the implementation needs to be as simple as possible</li> </ul> <p>And, for the thread pool, it should at least support these APIs:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">ThreadPool(std::size_t n)</code>: construct <code class="language-plaintext highlighter-rouge">n</code> threads for the thread pool</li> <li> <code class="language-plaintext highlighter-rouge">Stop</code>: stops the thread pool immediately, regardless of whether there are any outstanding tasks in the queue.</li> <li> <code class="language-plaintext highlighter-rouge">Enqueue</code>: push a task into the task list</li> <li> <code class="language-plaintext highlighter-rouge">~ThreadPool</code>: if the thread pool is not stopped, call <code class="language-plaintext highlighter-rouge">Stop</code> </li> <li>Cannot be copied/moved constructed/assigned</li> </ul> <p>My ideas about how to implement this thread pool:</p> <ol> <li>a thread pool with the specified number of threads is initialized</li> <li>these threads will wait (mutex, condition_variable) until a task appears in the queue <ol> <li>if notified, execute the task</li> <li>acquire a new task after finishing</li> <li>if there is no more task, wait</li> </ol> </li> <li>users can enqueue task into the list (mutex, function, promise, future, lambda) <ol> <li>user’s function will be encapsulated with parameters together to form a new callable</li> <li>the callable will be stored inside <code class="language-plaintext highlighter-rouge">std::function</code> </li> </ol> </li> </ol> <h2 id="challenges">Challenges</h2> <p>However, when I started to implement it, many problems suddenly appeared.</p> <h3 id="get-return-type-of-a-callable">Get Return Type of a Callable</h3> <p>The first question is how to correctly resolve the return type?</p> <p>First, we need a return type for the <code class="language-plaintext highlighter-rouge">Enqueue</code> function since we need to have a template argument for <code class="language-plaintext highlighter-rouge">std::future</code>. We can easily solve this by using automatic return type deduction introduced in C++14 (just use <code class="language-plaintext highlighter-rouge">auto</code> for the return type).</p> <p>Then, as we are dealing with a callable type, which can be a lambda, a function pointer or an object with overloaded <code class="language-plaintext highlighter-rouge">operator()</code>, we need a generic way to get its return type. That’s the use case of <code class="language-plaintext highlighter-rouge">std::invoke_result</code>. By passing the type of the callable and the type of the arguments, we can easily get the returned type from it. This is introduced since C++17.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// an example of std::invoke_result</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="c1">// other code</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="variadic-lambda">Variadic Lambda?</h3> <p>After solving the previous problem, we get another one: how to create a variadic lambda?</p> <p>The reason we need a lambda is that we need to encapsulate the callable from the user inside our callable, so that we could set the value of the <code class="language-plaintext highlighter-rouge">promise</code> when the task is executed. However, in order to encapsulate the user’s task inside our lambda, we need a lambda that can capture variadic parameters because the <code class="language-plaintext highlighter-rouge">Args</code> are variadic. Fortunately, this is a feature that is introduced in C++20.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// an example of variadic lambda</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="p">[...</span><span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)](){</span>
        <span class="c1">// code inside</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, it seems that we have gone too far from our second goal. Do we really need a lambda that captures variadic arguments?</p> <p>Since eventually, we need to store all the parameters into our task object (otherwise, we may not be able to support temporary value and may access objects after their lifetime), it’s reasonable to use <code class="language-plaintext highlighter-rouge">std::bind</code> instead of a lambda that captures variadic arguments. Also, it’s worth mentioning that <code class="language-plaintext highlighter-rouge">std::bind</code> is introduced in C++11.</p> <p>So, we finally have a solution:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="nolint">NOLINT</h3> <p>As I am using clang-tidy with some very “harsh” rules, it immediately gives me a warning for the use of <code class="language-plaintext highlighter-rouge">std::bind</code>. It reminds me to use lambda instead of <code class="language-plaintext highlighter-rouge">std::bind</code>. So, I need a way to bypass the linter. That’s the usage of <code class="language-plaintext highlighter-rouge">NOLINT</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span> <span class="c1">// NOLINT</span>
</code></pre></div></div> <h3 id="move-only-function">move-only-function</h3> <p>Things don’t go well as expected. It seems that I understand why people use an additional dynamic memory allocation for the <code class="language-plaintext highlighter-rouge">std::promise</code> or the <code class="language-plaintext highlighter-rouge">std::package_task</code>. It’s because these two types are not copyable.</p> <p>The fact that they are not copyable causes a huge problem when we want to construct a <code class="language-plaintext highlighter-rouge">std::function</code> by using a lambda that captures them. Because they are not copyable, the resulting lambda is also not copyable. However, <code class="language-plaintext highlighter-rouge">std::function</code> is supposed to be copyable, and it has a copy constructor. Therefore, we fail to instantiate the template.</p> <p>The solution to this problem is to use something called <code class="language-plaintext highlighter-rouge">std::move_only_function</code> introduced in C++23 (Thanks Jason Turner! I know this because I watched your video). Compared with the <code class="language-plaintext highlighter-rouge">std::function</code>, <code class="language-plaintext highlighter-rouge">std::move_only_function</code>, as its name suggests, can only be moved. Therefore, we could safely capture movable object in our lambda.</p> <p>However, it’s a C++23 feature, and I don’t want the user of my thread pool to install a <code class="language-plaintext highlighter-rouge">trunk</code> compiler just for the <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. So, I decide to provide a very naive implementation for <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. But people who can use <code class="language-plaintext highlighter-rouge">c++2b</code> should definitely use their <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. Therefore, I decide to use feature-test macro to help me do this.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef __cpp_lib_move_only_function
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">MoveOnlyFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move_only_function</span><span class="o">&lt;</span><span class="n">Signature</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#else
</span>  <span class="c1">// My MoveOnlyFunction here</span>
<span class="cp">#endif
</span></code></pre></div></div> <p>To understand how to implement the <code class="language-plaintext highlighter-rouge">std::move_only_function</code>, I recommend you to watch this great talk <a href="https://www.youtube.com/watch?v=tbUCHifyT24" rel="external nofollow noopener" target="_blank">Back to Basics: Type Erasure - Arthur O’Dwyer - CppCon 2019</a> by Arthur. You will learn what affordances are, how to implement hand-crafted type-erased classes, and how to rely on the v-table mechanism to implement type-erased classes.</p> <p>This is my naive implementation of <code class="language-plaintext highlighter-rouge">std::move_only_function</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">private:</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Callable</span> <span class="n">func_</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">Derived</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="o">:</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="p">{}</span>
    <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="k">final</span> <span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">func_impl_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="k">explicit</span> <span class="n">MoveOnlyFunction</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
<span class="k">explicit</span> <span class="nf">MoveOnlyFunction</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="c1">// NOLINT</span>
    <span class="o">:</span> <span class="n">func_impl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;&gt;</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span> <span class="p">{}</span>

<span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">func_impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">,</span> <span class="n">func_impl_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">func_impl_</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>Do notice that there is a very interesting trick about taking <code class="language-plaintext highlighter-rouge">Signature</code> as a template argument here. I provide a partial specialization of the class to actually make the <code class="language-plaintext highlighter-rouge">Signature</code> trick work.</p> <h2 id="the-final-code">The final code</h2> <p>The final implementation looks like this:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
<span class="nl">private:</span>
<span class="cp">#ifdef __cpp_lib_move_only_function
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">MoveOnlyFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move_only_function</span><span class="o">&lt;</span><span class="n">Signature</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#else
</span>  <span class="c1">// A simple implementation of MoveOnlyFunction</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="nl">public:</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="nl">private:</span>
      <span class="n">Callable</span> <span class="n">func_</span><span class="p">;</span>

    <span class="nl">public:</span>
      <span class="k">explicit</span> <span class="n">Derived</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="o">:</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="p">{}</span>
      <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="k">final</span> <span class="p">{</span>
        <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">func_impl_</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">MoveOnlyFunction</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="nf">MoveOnlyFunction</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="c1">// NOLINT</span>
        <span class="o">:</span> <span class="n">func_impl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;&gt;</span><span class="p">(</span>
              <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span> <span class="p">{}</span>

    <span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">func_impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">;</span>
      <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">,</span> <span class="n">func_impl_</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">func_impl_</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="cp">#endif
</span>
  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">MoveOnlyFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">tasks_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">{};</span>
  <span class="kt">bool</span> <span class="n">stopped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="nf">ThreadPool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">MoveOnlyFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{};</span> <span class="c1">// benchmark inside or outside</span>
          <span class="p">{</span>
            <span class="k">auto</span> <span class="n">ulock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lock_</span><span class="p">};</span>
            <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">ulock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">stopped_</span> <span class="o">||</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">tasks_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
            <span class="p">});</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">stopped_</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
            <span class="n">tasks_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="n">task</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">ThreadPool</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadPool</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">ThreadPool</span><span class="p">(</span><span class="n">ThreadPool</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ThreadPool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ThreadPool</span> <span class="o">&amp;</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
    <span class="n">stopped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="kr">thread</span> <span class="o">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">auto</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">Return_Type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Return_Type</span><span class="o">&gt;</span><span class="p">{};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lock_</span><span class="p">};</span>
      <span class="n">tasks_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
          <span class="p">[</span><span class="n">promise</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">promise</span><span class="p">),</span>
           <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)]()</span> <span class="k">mutable</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">Return_Type</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
              <span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
            <span class="p">}</span>
          <span class="p">});</span>
    <span class="p">}</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">future</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="benchmark">Benchmark</h2> <p>I create a simple benchmark for my implementation. I compare it with one of the most famous <a href="https://github.com/bshoshany/thread-pool" rel="external nofollow noopener" target="_blank">implementation</a> in Github.</p> <p>The benchmark code is something like this:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Timer</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_start_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">())</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">Timer</span><span class="p">()</span> <span class="p">{</span> <span class="n">Stop</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_start_</span><span class="p">)</span>
            <span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()</span>
            <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">stop</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
            <span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()</span>
            <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Duration: "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span> <span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span> <span class="n">m_start_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">auto</span> <span class="n">Worker</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ThreadPoolTest</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// different thread pool is used here</span>
  <span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()};</span>
  <span class="n">Timer</span> <span class="n">timer</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">result</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">Worker</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">future</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>I have plotted a graph for the benchmark results and it looks very good. (All the code are compiled with <code class="language-plaintext highlighter-rouge">-Ofast</code>).</p> <p><img src="/assets/img/blog/2023/01/threadpool-benchmark.svg" alt="benchmark"></p> <p>By using <code class="language-plaintext highlighter-rouge">hyperfine</code>, I am able to get the following result</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Benchmark 1: ./bench (my thread pool)
  Time (mean ± σ):     11.814 s ±  0.366 s    [User: 81.934 s, System: 1.862 s]
  Range (min … max):   11.410 s … 12.335 s    10 runs

Benchmark 2: ./bench-bs (bs thread pool light)
  Time (mean ± σ):     12.680 s ±  0.061 s    [User: 88.338 s, System: 1.866 s]
  Range (min … max):   12.578 s … 12.766 s    10 runs

Summary
  './bench' ran
    1.07 ± 0.03 times faster than './bench-bs'
</code></pre></div></div> <p>So, it’s roughly 1.1 times faster than bs’s implementation.</p> <h2 id="improvements">Improvements</h2> <p>There are certainly many rooms for improvements.</p> <ol> <li> <p>One can argue that the API is far less than enough as it provides no way to inspect the number of tasks and threads. In addition, there is not enough customisability: the user cannot decide how to start the thread (in detached mode or joined mode).</p> </li> <li> <p>The task queue can be implemented via some lock-free mechanisms. To further reduce the contention, we can even create a queue for every thread and implement work-stealing mechanism.</p> </li> <li> <p>Possible optimizations of <code class="language-plaintext highlighter-rouge">MoveOnlyFunction</code>. For <code class="language-plaintext highlighter-rouge">std::string</code>, we have something called Small String Optimization (SSO). The same solution exists for <code class="language-plaintext highlighter-rouge">std::function</code>, which is known as Small Function Optimization (SFO). We can apply this to <code class="language-plaintext highlighter-rouge">MoveOnlyFunction</code> to save us one dynamic memory allocation for small callable objects.</p> </li> <li> <p>Exception guarantee. Currently, we neglect the exception guarantee provided by the user. We should take this into account when packaging user’s callable and arguments into a task.</p> </li> </ol> <h2 id="what-i-learned">What I learned</h2> <ol> <li><code class="language-plaintext highlighter-rouge">std::invoke_result</code></li> <li>lambda that captures variadic arguments</li> <li><code class="language-plaintext highlighter-rouge">std::move_only_function</code></li> <li>more about lambda captures <ol> <li><a href="https://stackoverflow.com/questions/3772867/lambda-capture-as-const-reference" rel="external nofollow noopener" target="_blank">Lambda capture as const reference?</a></li> </ol> </li> <li>type-erased class in practice</li> <li>meta-programming in practice <ol> <li>perfect forwarding</li> <li><code class="language-plaintext highlighter-rouge">if constexpr</code></li> <li>type traits</li> </ol> </li> </ol> </div> </article> </div> </div> <div class="caption post-version"> v25-02-26 | <a href="https://github.com/yuxqiu/yuxqiu.github.io/commit/dc6ef00cd19ab33c117ef5320c28635073afa9a8" rel="external nofollow noopener" target="_blank">dc6ef00</a> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> </body> </html>