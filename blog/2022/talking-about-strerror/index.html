<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta name="view-transition" content="same-origin"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="author" content="Yuxiang Qiu"> <title>Talking about strerror (and why you should be cautious when using it) | Yuxiang Qiu</title> <meta name="generator" content="Jekyll v4.4.1"> <meta property="og:title" content="Talking about strerror (and why you should be cautious when using it)"> <meta property="og:locale" content="en"> <meta name="description" content="If you have ever used C/C++ before, you must know a very important global variable errno (though it can be a macro). Through this variable, we can get information about the library function call (whether it succeeds? If it fails, what’s the type of error?). However, errno is just a number, and we want to interpret its meaning. Thus, we need some functions for us to “interpret” it. That’s the reason why strerror exists."> <meta property="og:description" content="If you have ever used C/C++ before, you must know a very important global variable errno (though it can be a macro). Through this variable, we can get information about the library function call (whether it succeeds? If it fails, what’s the type of error?). However, errno is just a number, and we want to interpret its meaning. Thus, we need some functions for us to “interpret” it. That’s the reason why strerror exists."> <link rel="canonical" href="https://yuxqiu.github.io/blog/2022/talking-about-strerror/"> <meta property="og:url" content="https://yuxqiu.github.io/blog/2022/talking-about-strerror/"> <meta property="og:site_name" content="Yuxiang Qiu"> <meta property="og:image" content="https://yuxqiu.github.io/assets/img/og/posts/talking-about-strerror.png"> <meta property="og:image:height" content="600"> <meta property="og:image:width" content="1200"> <meta property="og:image:alt" content="Talking about strerror (and why you should be cautious when using it)"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2022-09-15T20:15:48+00:00"> <meta name="twitter:card" content="summary_large_image"> <meta property="twitter:image" content="https://yuxqiu.github.io/assets/img/og/posts/talking-about-strerror.png"> <meta name="twitter:image:alt" content="Talking about strerror (and why you should be cautious when using it)"> <meta property="twitter:title" content="Talking about strerror (and why you should be cautious when using it)"> <meta name="twitter:site" content="@yuxqiu"> <meta name="google-site-verification" content="OyP7PF7v8xjEbPqbdYaMosljunIcAOjdw_C6-TtA8f0"> <meta name="msvalidate.01" content="231286930EDC7A744F88D1D05B1BD04A"> <script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-18T14:33:14+00:00","datePublished":"2022-09-15T20:15:48+00:00","description":"If you have ever used C/C++ before, you must know a very important global variable errno (though it can be a macro). Through this variable, we can get information about the library function call (whether it succeeds? If it fails, what’s the type of error?). However, errno is just a number, and we want to interpret its meaning. Thus, we need some functions for us to “interpret” it. That’s the reason why strerror exists.","headline":"Talking about strerror (and why you should be cautious when using it)","image":{"width":1200,"height":600,"alt":"Talking about strerror (and why you should be cautious when using it)","url":"https://yuxqiu.github.io/assets/img/og/posts/talking-about-strerror.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuxqiu.github.io/blog/2022/talking-about-strerror/"},"url":"https://yuxqiu.github.io/blog/2022/talking-about-strerror/"}</script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2022/talking-about-strerror/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuxiang Qiu </a> <input type="checkbox" id="navbar-toggler-checkbox" class="navbar-toggler-checkbox" hidden> <label for="navbar-toggler-checkbox" class="navbar-toggler ml-auto"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </label> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/ss/index.html">SS </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <svg id="light-toggle-system" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg> <svg id="light-toggle-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 1.992a10 10 0 1 0 9.236 13.838c.341 -.82 -.476 -1.644 -1.298 -1.31a6.5 6.5 0 0 1 -6.864 -10.787l.077 -.08c.551 -.63 .113 -1.653 -.758 -1.653h-.266l-.068 -.006l-.06 -.002z"></path></svg> <svg id="light-toggle-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path></svg> </button> </li> </ul> </div> </div> </nav> </header> <main class="container mt-5 flex-grow-1" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Talking about strerror (and why you should be cautious when using it)</h1> </header> <article class="post-content"> <hr> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#what-is-strerror">What is strerror</a></li> <li class="toc-entry toc-h2"><a href="#solutions-before-c11">Solutions before C11</a></li> <li class="toc-entry toc-h2"><a href="#the-evilness-of-strerror_r">The evilness of strerror_r</a></li> <li class="toc-entry toc-h2"><a href="#solution-after-c11">Solution after C11</a></li> <li class="toc-entry toc-h2"><a href="#what-about-c">What about C++?</a></li> </ul> </div> <hr> <div id="markdown-content"> <p>If you have ever used C/C++ before, you must know a very important global variable <code class="language-plaintext highlighter-rouge">errno</code> (though it can be a macro). Through this variable, we can get information about the library function call (whether it succeeds? If it fails, what’s the type of error?). However, <code class="language-plaintext highlighter-rouge">errno</code> is just a number, and we want to interpret its meaning. Thus, we need some functions for us to “interpret” it. That’s the reason why <code class="language-plaintext highlighter-rouge">strerror</code> exists.</p> <h2 id="what-is-strerror">What is <code class="language-plaintext highlighter-rouge">strerror</code> </h2> <p>Let’s first take a look at the signature of the function.</p> <p><code class="language-plaintext highlighter-rouge">char* strerror( int errnum );</code></p> <p>The function takes in an integer <code class="language-plaintext highlighter-rouge">errnum</code> and “returns a pointer to the textual description of the system error code errnum”<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p> <p>The description is very vague, but we do know</p> <ul> <li>We don’t need to free the memory of the <code class="language-plaintext highlighter-rouge">char *</code> returned from this function</li> <li>We don’t need to make sure <code class="language-plaintext highlighter-rouge">errnum</code> is in the valid range of <code class="language-plaintext highlighter-rouge">errno</code> </li> </ul> <p>Let’s read the rest of the description:</p> <blockquote> <p>The returned string must not be modified by the program but may be overwritten by a subsequent call to the <code class="language-plaintext highlighter-rouge">strerror</code> function. <code class="language-plaintext highlighter-rouge">strerror</code> is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which <code class="language-plaintext highlighter-rouge">strerror</code> places the string.</p> </blockquote> <p>So, why the string returned may be overwritten by subsequent calls? To better understand it, let’s imagine you need to implement a function that maps some integers to error messages. What would you do? I believe most of you, including me, will define some <code class="language-plaintext highlighter-rouge">const char*</code> strings as messages and returns one of them to the user. As far as I know, most implementations simply return a <code class="language-plaintext highlighter-rouge">const char*</code> to the user.</p> <p>So, where does the possible overwriting come from? Let’s look at the signature again <code class="language-plaintext highlighter-rouge">char* strerror( int errnum );</code>. It’s the <code class="language-plaintext highlighter-rouge">errnum</code>. Remember, we could pass anything that is an <code class="language-plaintext highlighter-rouge">int</code> to this function. What would happen if we pass an integer, not in the range of the <code class="language-plaintext highlighter-rouge">errno</code>? (Clearly, your system doesn’t have that many error types).</p> <p>Let’s see what would happen with the following programs:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p>In my macOS Monterey 12.6, I get <code class="language-plaintext highlighter-rouge">Unknown error: -1</code>. You can see that it outputs the integer that we pass to the function.</p> <p>If you are familiar with C, you may immediately realize how we could implement it: a static buffer inside this function with some predefined <code class="language-plaintext highlighter-rouge">const char*</code> message strings. If we have a valid <code class="language-plaintext highlighter-rouge">errnum</code>, we return one of the message strings; otherwise, we construct one inside our buffer and return the address of the buffer.</p> <p>That’s the root of evil.</p> <h2 id="solutions-before-c11">Solutions before C11</h2> <p>Imagine if you want to implement a multi-threaded web server. You use system functions to create a socket and read/write data. Suppose some bad things happen, and two of your threads need to use <code class="language-plaintext highlighter-rouge">strerror</code> to acquire the error messages. Now, you face this situation:</p> <ul> <li>You know most implementations return a <code class="language-plaintext highlighter-rouge">const char*</code> for valid <code class="language-plaintext highlighter-rouge">errno</code> </li> <li>However, in theory, “strerror is not required to be thread-safe” (because of the static buffer). So if some unwise people, when developing this function, copy the error message to a static buffer and return it, you will have no idea what error messages you will get.</li> </ul> <p>So, how could we mitigate this (before C11) if we want a portable version of <code class="language-plaintext highlighter-rouge">strerror</code>?</p> <ol> <li>Create a wrapper function and use a <code class="language-plaintext highlighter-rouge">mutex</code>. There are two possible implementations: <ol> <li>Before releasing the <code class="language-plaintext highlighter-rouge">mutex</code>, copy the string into a dynamically allocated buffer. This method requires the user to free the returned result.</li> <li>Accept a user-provided buffer as a parameter and take in another parameter which is the size of the buffer. Copy the string into the buffer based on the given size.</li> </ol> </li> <li>You could use <code class="language-plaintext highlighter-rouge">sys_nerr</code> and <code class="language-plaintext highlighter-rouge">sys_errlist</code>. The first argument is the length of the <code class="language-plaintext highlighter-rouge">sys_errlist</code>, and the second is an array that stores pointers to error messages. The detailed usage is not provided here because it is “deprecated and declared inconsistently” in some systems<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</li> <li>Use <code class="language-plaintext highlighter-rouge">strerror_r</code> (which is another evil function)</li> </ol> <h2 id="the-evilness-of-strerror_r">The evilness of <code class="language-plaintext highlighter-rouge">strerror_r</code> </h2> <p><code class="language-plaintext highlighter-rouge">strerror_r</code> is defined by POSIX as <code class="language-plaintext highlighter-rouge">int strerror_r(int errnum, char *buf, size_t buflen);</code>.</p> <blockquote> <p>However, it has a different, non-standard prototype in glibc versus in POSIX: <code class="language-plaintext highlighter-rouge">char *strerror_r(int errnum, char *buf, size_t buflen);</code> Even if you don’t define _GNU_SOURCE or any other of the feature macros, you’ll still get the non-POSIX definition on Linux. Ok, you say, no big problem. I don’t expect strerror_r to fail, so I should be able to get by with code like this:</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">strerror_r</span><span class="p">(</span><span class="n">errnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <span class="c1">// do NOT do this!</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"foobar failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div></div> <blockquote> <p>But, as the comment indicates, you must not do this. The GNU function doesn’t usually modify the provided buffer– it only modifies it sometimes. If you end up with the GNU version, you must use the return value of the function as the string to print<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.</p> </blockquote> <h2 id="solution-after-c11">Solution after C11</h2> <p>We finally see some great news since C11. We now have a improvded function in C standards: <code class="language-plaintext highlighter-rouge">errno_t strerror_s( char *buf, rsize_t bufsz, errno_t errnum );</code></p> <blockquote> <p>…The message is copied into user-provided storage <code class="language-plaintext highlighter-rouge">buf</code>. No more than <code class="language-plaintext highlighter-rouge">bufsz-1</code> bytes are written, and the buffer is always null-terminated. If the message had to be truncated to fit the buffer and <code class="language-plaintext highlighter-rouge">bufsz</code> is greater than 3, then only <code class="language-plaintext highlighter-rouge">bufsz-4</code> bytes are written, and the characters “…” are appended before the null terminator.</p> </blockquote> <p>So, use this function if your project uses <code class="language-plaintext highlighter-rouge">C11</code> or above.</p> <h2 id="what-about-c">What about C++?</h2> <p>Sadly, C++ doesn’t have <code class="language-plaintext highlighter-rouge">strerror_s</code> or <code class="language-plaintext highlighter-rouge">strerror_r</code>. The only thing we have is <code class="language-plaintext highlighter-rouge">strerror</code>. So, create a wrapper and use a <code class="language-plaintext highlighter-rouge">mutex</code> if you care about “perfect portability”.</p> <p>Also, you should avoid using <code class="language-plaintext highlighter-rouge">&lt;system_error&gt;</code> (at least avoid using the error associated with <code class="language-plaintext highlighter-rouge">std::error_code</code>) for the same reason since its internal mechanism uses <code class="language-plaintext highlighter-rouge">strerror</code> to convert the system error code into the error message<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p><a href="https://en.cppreference.com/w/c/string/byte/strerror" rel="external nofollow noopener" target="_blank">cppreference.com: strerror, strerror_s, strerrorlen_s</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2"> <p><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/strerror.3.html" rel="external nofollow noopener" target="_blank">Mac OS X manual page for strerror(3)</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p><a href="http://www.club.cc.cmu.edu/~cmccabe/blog_strerror.html" rel="external nofollow noopener" target="_blank">2012-08-12: A portable strerror_r</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:4"> <p><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/system_error" rel="external nofollow noopener" target="_blank">libstdc++ implementation of system_error</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> </div> </main> <footer class="sticky-bottom" role="contentinfo"> <div class="post-version"> © 2025 <a href="/">Yuxiang Qiu</a> <br> v25-02-18 | <a href="https://github.com/yuxqiu/yuxqiu.github.io/commit/164661fe14bea1e047a15eeaa5ed3429c0d08a3e" rel="external nofollow noopener" target="_blank">164661f</a> </div> </footer> </body> </html>