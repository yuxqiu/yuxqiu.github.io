<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta name="view-transition" content="same-origin"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="author" content="Yuxiang Qiu"> <title>Memcpy and Undefined Behavior | Yuxiang Qiu</title> <meta name="generator" content="Jekyll v4.4.1"> <meta property="og:title" content="Memcpy and Undefined Behavior"> <meta property="og:locale" content="en"> <meta name="description" content="Introduction"> <meta property="og:description" content="Introduction"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2022/memcpy-union/"> <meta property="og:url" content="https://yuxqiu.github.io/blog/2022/memcpy-union/"> <meta property="og:site_name" content="Yuxiang Qiu"> <meta property="og:image" content="https://yuxqiu.github.io/assets/img/og/posts/memcpy-union.png"> <meta property="og:image:height" content="600"> <meta property="og:image:width" content="1200"> <meta property="og:image:alt" content="Memcpy and Undefined Behavior"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2022-12-05T09:05:17+00:00"> <meta name="twitter:card" content="summary_large_image"> <meta property="twitter:image" content="https://yuxqiu.github.io/assets/img/og/posts/memcpy-union.png"> <meta name="twitter:image:alt" content="Memcpy and Undefined Behavior"> <meta property="twitter:title" content="Memcpy and Undefined Behavior"> <meta name="twitter:site" content="@yuxqiu"> <meta name="google-site-verification" content="OyP7PF7v8xjEbPqbdYaMosljunIcAOjdw_C6-TtA8f0"> <meta name="msvalidate.01" content="231286930EDC7A744F88D1D05B1BD04A"> <script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-22T10:58:12+00:00","datePublished":"2022-12-05T09:05:17+00:00","description":"Introduction","headline":"Memcpy and Undefined Behavior","image":{"width":1200,"height":600,"alt":"Memcpy and Undefined Behavior","url":"https://yuxqiu.github.io/assets/img/og/posts/memcpy-union.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuxqiu.github.io/blog/2022/memcpy-union/"},"url":"https://yuxqiu.github.io/blog/2022/memcpy-union/"}</script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="/assets/css/mdb.min.css?62a43d1430ddb46fc4886f9d0e3b49b8"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuxqiu.github.io/blog/2022/memcpy-union/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuxiang Qiu </a> <input type="checkbox" id="navbar-toggler-checkbox" class="navbar-toggler-checkbox" hidden> <label for="navbar-toggler-checkbox" class="navbar-toggler ml-auto"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </label> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/ss/index.html">SS </a> </li> <li class="nav-item "> <a class="nav-link" href="/now/">Now </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <svg id="light-toggle-system" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg> <svg id="light-toggle-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 1.992a10 10 0 1 0 9.236 13.838c.341 -.82 -.476 -1.644 -1.298 -1.31a6.5 6.5 0 0 1 -6.864 -10.787l.077 -.08c.551 -.63 .113 -1.653 -.758 -1.653h-.266l-.068 -.006l-.06 -.002z"></path></svg> <svg id="light-toggle-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="currentColor"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path></svg> </button> </li> </ul> </div> </div> </nav> </header> <main class="container mt-5 flex-grow-1" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Memcpy and Undefined Behavior</h1> </header> <article class="post-content"> <hr> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h2"><a href="#c-standard-library">C++ Standard Library</a></li> <li class="toc-entry toc-h2"><a href="#class-layout">Class Layout</a></li> <li class="toc-entry toc-h2"><a href="#strict-aliasing">Strict Aliasing</a></li> <li class="toc-entry toc-h2"><a href="#trap-representation">Trap Representation</a></li> <li class="toc-entry toc-h2"><a href="#memcpy">Memcpy</a></li> <li class="toc-entry toc-h2"><a href="#some-discussions-about-union">Some discussions about Union</a></li> <li class="toc-entry toc-h2"><a href="#open-questions">Open Questions</a></li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="introduction">Introduction</h2> <p>The aim of this article is to provide an axiomatic way of understanding <code class="language-plaintext highlighter-rouge">memcpy</code> and the undefined behaviour associated with it.</p> <p>Before talking about the <code class="language-plaintext highlighter-rouge">memcpy</code>, it’s necessary to understand</p> <ul> <li>some basics about C++ Standard Library</li> <li>C++ class layout</li> <li>Strict Aliasing</li> </ul> <h2 id="c-standard-library">C++ Standard Library</h2> <blockquote> <p>[defns.undefined]: undefined behavior is behavior for which this document imposes no requirements</p> </blockquote> <blockquote> <p>[library.c]: The descriptions of many library functions rely on the C standard library for the semantics of those functions. In some cases, the signatures specified in this document may be different from the signatures in the C standard library, and additional overloads may be declared in this document, but the behavior and the preconditions (including any preconditions implied by the use of an ISO C restrict qualifier) are the same unless otherwise stated.</p> </blockquote> <h2 id="class-layout">Class Layout</h2> <blockquote> <p><a href="https://learn.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170" rel="external nofollow noopener" target="_blank">Trivial, standard-layout, POD, and literal types</a></p> </blockquote> <ol> <li>Trivial Types <ol> <li>Definition <ol> <li>no virtual functions or virtual base classes,</li> <li>no base classes with a corresponding non-trivial constructor/operator/destructor</li> <li>no data members of class type with a corresponding non-trivial constructor/operator/destructor</li> </ol> </li> <li>Notes <ol> <li>Trivial Types can have different access modifiers</li> <li>The C++ Standard places no requirements on the layout between different class modifiers. Compilers can feel free to optimize these (e.g. move private members to lower memory address even though they are declared after public members)</li> <li><a href="https://stackoverflow.com/a/52745420" rel="external nofollow noopener" target="_blank">Potential optimizations that can be done</a></li> </ol> </li> </ol> </li> <li>Standard layout types <ol> <li>no virtual functions or virtual base classes</li> <li>all non-static data members have the same access control</li> <li>all non-static members of class type are standard-layout</li> <li>any base classes are standard-layout</li> <li>has no base classes of the same type as the first non-static data member.</li> <li>meets one of these conditions: <ol> <li>no non-static data member in the most-derived class and no more than one base class with non-static data members, or</li> <li>has no base classes with non-static data members</li> </ol> </li> </ol> </li> <li>POD <ol> <li>Both Trivial and Standard Layout</li> </ol> </li> </ol> <h2 id="strict-aliasing">Strict Aliasing</h2> <blockquote> <p><a href="https://en.cppreference.com/w/cpp/language/object#Strict_aliasing" rel="external nofollow noopener" target="_blank">Strict Aliasing</a></p> <p><a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing" rel="external nofollow noopener" target="_blank">Type aliasing</a></p> </blockquote> <p>Whenever an attempt is made to <strong>read or modify</strong> the stored value of an object of type DynamicType through a glvalue of type AliasedType, the behavior is undefined unless one of the following is true:</p> <ul> <li>AliasedType and DynamicType are <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing" rel="external nofollow noopener" target="_blank">similar</a>.</li> <li>AliasedType is the (possibly cv-qualified) signed or unsigned variant of DynamicType.</li> <li>AliasedType is std::byte, (since C++17) char, or unsigned char: this permits examination of the object representation of any object as an array of bytes.</li> </ul> <p>More about Strict Aliasing</p> <ul> <li><a href="https://stackoverflow.com/a/98702" rel="external nofollow noopener" target="_blank">An intuitive way to understand strict aliasing</a></li> <li><a href="https://stackoverflow.com/a/18929285" rel="external nofollow noopener" target="_blank">Casting to void* and Casting back is perfectly defined</a></li> </ul> <h2 id="trap-representation">Trap Representation</h2> <ol> <li><a href="https://stackoverflow.com/questions/6725809/trap-representation/6725981#6725981" rel="external nofollow noopener" target="_blank">What is a trap representation</a></li> <li> <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2091.htm#problem" rel="external nofollow noopener" target="_blank">What happens if we read a trap based on its type</a> <ol> <li>This applies as C++ (at least after 17) uses C11 as its normative references [intro.refs]</li> </ol> </li> <li> <a href="https://en.cppreference.com/w/cpp/language/object#Object_representation_and_value_representation" rel="external nofollow noopener" target="_blank">Guarantee provided by C++ standard</a> <ol> <li>This is the best justification I can find: [basic.fundamental.7] Type char is a distinct type that has an implementation-defined choice of “signed char” or “unsigned char” as its underlying type. The values of type char can represent distinct codes for all members of the implementation’s basic character set. The three types char, signed char, and unsigned char are collectively called ordinary character types. The ordinary character types and <code class="language-plaintext highlighter-rouge">char8_t</code> are collectively called narrow character types. For narrow character types, each possible bit pattern of the object representation represents a distinct value.</li> </ol> </li> </ol> <h2 id="memcpy">Memcpy</h2> <p>So, what does the standard say about memcpy exactly? The standard mentions <code class="language-plaintext highlighter-rouge">std::memcpy</code> multiple times. But the quotes that cause many confusions is in [basic.types]:</p> <blockquote> <p>For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes (6.6.1) making up the object can be copied into an array of char, unsigned char, or std::byte (21.2.1). If the content of that array is copied back into the object, the object shall subsequently hold its original value. Example:</p> <div class="language-c++ highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="cp">#define N sizeof(T)
</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">T</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// obj initialized to its original value</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span> <span class="c1">// between these two calls to std::memcpy, obj might be modified</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span> <span class="c1">// at this point, each subobject of obj of scalar type holds its original value</span>
</code></pre></div> </div> <p>For any trivially copyable type T, if two pointers to T point to distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a base-class subobject, if the underlying bytes (6.6.1) making up obj1 are copied into obj2, obj2 shall subsequently hold the same value as obj1. Example:</p> <div class="language-c++ highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="o">*</span> <span class="n">t1p</span><span class="p">;</span>
<span class="n">T</span><span class="o">*</span> <span class="n">t2p</span><span class="p">;</span>
<span class="c1">// provided that t2p points to an initialized object ...</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">t1p</span><span class="p">,</span> <span class="n">t2p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
<span class="c1">// at this point, every subobject of trivially copyable type in *t1p contains</span>
<span class="c1">// the same value as the corresponding subobject in *t2p</span>
</code></pre></div> </div> </blockquote> <p>Here, the standard lists two ways that are perfectly defined: we can copy to buffers of narrow character type and restore the object, or we can directly copy into another object of the same type. Some people believe that based on “[defns.undefined]”, other uses of <code class="language-plaintext highlighter-rouge">memcpy</code> are not properly defined.</p> <p>However, this is the time we need to directly refer to the <code class="language-plaintext highlighter-rouge">memcpy</code>. The C++ standard states that</p> <ul> <li>If the objects are potentially-overlapping or not TriviallyCopyable, the behavior of <code class="language-plaintext highlighter-rouge">memcpy</code> is not specified and may be undefined.<input type="checkbox" id="rf1" class="sidenote"><label for="rf1"><sup>1</sup></label><span><sup>1</sup> <a href="https://en.cppreference.com/w/cpp/string/byte/memcpy" rel="external nofollow noopener" target="_blank">std::memcpy</a></span> </li> <li>Plus all the things stated by C standard (My Point) <ul> <li>Based on “[library.c]”</li> </ul> </li> </ul> <p>So far, it looks like we have solid grounds to use <code class="language-plaintext highlighter-rouge">memcpy</code> in C++ as long as we are manipulating Trivially Copyable Types. However, some people mention about the trap, claiming that it’s undefined behavior if we try to access the value based on the type that has trap representation. So, they believe it’s not safe to copy from a type <code class="language-plaintext highlighter-rouge">T</code> to a type <code class="language-plaintext highlighter-rouge">U</code> unless <code class="language-plaintext highlighter-rouge">U</code> is of narrow character types or <code class="language-plaintext highlighter-rouge">U == T</code> (given that the destination has enough size for the src).<input type="checkbox" id="rf2" class="sidenote"><label for="rf2"><sup>2</sup></label><span><sup>2</sup> <a href="https://stackoverflow.com/questions/51300626/is-stdmemcpy-between-different-trivially-copyable-types-undefined-behavior/" rel="external nofollow noopener" target="_blank">Is std::memcpy between different trivially copyable types undefined behavior?</a></span></p> <p>However, my point is <code class="language-plaintext highlighter-rouge">memcpy</code> is noy affected by the existence of trap representation because as the standard explicitly stated in <code class="language-plaintext highlighter-rouge">std::memcpy</code>: “both objects (the src and dest pointers) are reinterpreted as arrays of unsigned char.” Since we are not accessing the object of Type <code class="language-plaintext highlighter-rouge">U</code> via the type <code class="language-plaintext highlighter-rouge">U</code> itself, we are in the safe realm.</p> <p>So, in summary, given the requirements about “size”, “not overlapping”, “trivially copyable”, we can:</p> <ul> <li>Copy some bytes into some buffer (don’t necessarily need to be narrow character types or the types of the src object)</li> <li>Restore an object by copying from some buffer to the storage of the object</li> </ul> <hr> <p>Note-1: <code class="language-plaintext highlighter-rouge">memcpy</code> for Standard Layout Types:</p> <ul> <li><a href="https://stackoverflow.com/questions/52871481/can-i-memcpy-objects-data-which-has-standard-layout-compatible-class-in-c11" rel="external nofollow noopener" target="_blank">Why is the behavior of memcpy unspecified, and probably undefined for standard layout types - 1</a></li> <li><a href="https://stackoverflow.com/questions/29777492/why-would-the-behavior-of-stdmemcpy-be-undefined-for-objects-that-are-not-triv" rel="external nofollow noopener" target="_blank">Why is the behavior of memcpy unspecified, and probably undefined for standard layout types - 2</a></li> </ul> <h2 id="some-discussions-about-union">Some discussions about Union</h2> <ol> <li><a href="https://adriann.github.io/undefined_behavior.html" rel="external nofollow noopener" target="_blank">Union is Undefined Behavior</a></li> <li><a href="https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-and-undefined-behavior" rel="external nofollow noopener" target="_blank">Accessing inactive union member and undefined behavior?</a></li> </ol> <h2 id="open-questions">Open Questions</h2> <ul> <li>Are undefined behaviors always bad? Why don’t we make some of UB as implementations defined behaviors?</li> <li>How should we interpret the C++ standard?</li> </ul> </div> </article> </div> </main> <footer class="sticky-bottom" role="contentinfo"> <div class="post-version"> © 2025 <a href="/">Yuxiang Qiu</a> <br> v25-07-22 | <a href="https://github.com/yuxqiu/yuxqiu.github.io/commit/f91d1d185f1e5774ef69bbead35dd305563d54cc" rel="external nofollow noopener" target="_blank">f91d1d1</a> </div> </footer> </body> </html>