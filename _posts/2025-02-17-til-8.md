---
layout: post
title: "TIL: Colliding Secure Hashes, FIFO and LRU Cache"
date: 2025-02-17 12:51:25
tags: ["TIL", "Cryptography", "Algorithm", "Systems"]

toc: true
mathjax: true
featured: false
---

## Colliding Secure Hashes

- [Colliding Secure Hashes](https://www.da.vidbuchanan.co.uk/blog/colliding-secure-hashes.html)

It's interesting to see [Pollard's Rho Algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) can be used in finding collision. Intuitively, this works because: the hash we try to break is a secure hash -> so it behaves like a PRF -> by the birthday paradox, we can find collisions in the same amount of time as naive birthday bruteforce algorithm.
- The article reminds me of [Floyd's Tortoise and Hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd%27s_tortoise_and_hare). A long time ago, I remember running into this algorithm in Leetcode.

{:refdef: style="text-align: center;"}
![parallel pollard's rho](/assets/img/blog/2025/02/parallel-pollard-rho.png){:width="60%"}
{: refdef}

The [Parallel Pollard's Rho](https://www.cs.csi.cuny.edu/~zhangx/papers/P_2018_LISAT_Weber_Zhang.pdf) method explores the time-space tradeoff (controlled by the distinguisher function) + parallelization. For a $n$-bit hash and a distinguisher function enforcing the first $k$-bit of the hash to be 0, a quick math gives us the following:
- Space Complexity: $O(2^{\frac{(n-k)}{2}})$.
- Time Complexity: $O(2^k * 2^{\frac{n-k}{2}})$.
- As expected, the product of them is $O(2^n)$.

## FIFO can be Better than LRU

- [FIFO can be Better than LRU: the Power of Lazy Promotion and Quick Demotion](https://jasony.me/publication/hotos23-qdlp.pdf)

Wonderfully simple ideas and very intuitive!

{:refdef: style="text-align: center;"}
![cache-abstraction](/assets/img/blog/2025/02/cache-abstraction.png){:width="80%"}
{: refdef}

*Lazy Promotion*
- Their assumptions about popularity decay are basically in line with what I've encountered in real life.
- Notably, this strategy also applies to the traditional LRU (simply replace eager promotion with lazy promotion). But, in such case, simply using FIFO is a much wiser choice.

*Quick Demotion*
- Q: How to balance the size of the probationary FIFO queue? (parameter selection)