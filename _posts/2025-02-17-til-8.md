---
layout: post
title: "TIL: Colliding Secure Hashes"
date: 2025-02-17 12:51:25
tags: ["TIL", "Cryptography", "Algorithm"]

toc: true
mathjax: true
featured: false
---

## Colliding Secure Hashes

- [Colliding Secure Hashes](https://www.da.vidbuchanan.co.uk/blog/colliding-secure-hashes.html)

It's interesting to see [Pollard's Rho Algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) can be used in finding collision. Intuitively, this works because: the hash we try to break is a secure hash -> so it behaves like a PRF -> by the birthday paradox, we can find collisions in the same amount of time as naive birthday bruteforce algorithm.
- The article reminds me of [Floyd's Tortoise and Hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd%27s_tortoise_and_hare). A long time ago, I remember running into this algorithm in Leetcode.

{:refdef: style="text-align: center;"}
![parallel pollard's rho](/assets/img/blog/2025/02/parallel-pollard-rho.png){:width="60%"}
{: refdef}

The [Parallel Pollard's Rho](https://www.cs.csi.cuny.edu/~zhangx/papers/P_2018_LISAT_Weber_Zhang.pdf) method explores the time-space tradeoff (controlled by the distinguisher function) + parallelization. For a n-bit hash and a distinguisher function enforcing that the first k-bit is 0, a quick math gives us the following info:
- Space Complexity: $O(2^{\frac{(n-k)}{2}})$.
- Time Complexity: $O(2^k * 2^{\frac{n-k}{2}})$.
- As expected, the product of them is $O(2^n)$.
