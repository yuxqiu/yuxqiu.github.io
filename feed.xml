<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://yuxqiu.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://yuxqiu.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-18T00:53:42+00:00</updated><id>https://yuxqiu.github.io/feed.xml</id><title type="html">Yuxiang Qiu</title><subtitle>Yuxiang Qiu</subtitle><entry><title type="html">Linear Code, Reed-Soloman Code, e-far, Recursive Encoding, and Lossless Expander</title><link href="https://yuxqiu.github.io/blog/2024/zkp-lec-7/" rel="alternate" type="text/html" title="Linear Code, Reed-Soloman Code, e-far, Recursive Encoding, and Lossless Expander"/><published>2024-09-15T10:46:10+00:00</published><updated>2024-09-15T10:46:10+00:00</updated><id>https://yuxqiu.github.io/blog/2024/zkp-lec-7</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2024/zkp-lec-7/"><![CDATA[<blockquote> <p>This is still WIP. I’ll update it gradually.</p> </blockquote> <h2 id="linear-code">Linear Code</h2> <h2 id="reed-soloman-code">Reed-Soloman Code</h2> <h2 id="e-far-and-e-close">e-far and e-close</h2> <h2 id="proof-constant-relative-distance-of-recursive-encoding">Proof: Constant Relative Distance of Recursive Encoding</h2> <h2 id="random-sampling-of-lossless-expander">Random Sampling of Lossless Expander</h2>]]></content><author><name></name></author><category term="ZKP"/><category term="Applied Cryptography"/><summary type="html"><![CDATA[This is still WIP. I’ll update it gradually.]]></summary></entry><entry><title type="html">Non-Interactivity and Graph Non-Isomorphism</title><link href="https://yuxqiu.github.io/blog/2024/zkp-lec-1/" rel="alternate" type="text/html" title="Non-Interactivity and Graph Non-Isomorphism"/><published>2024-09-10T14:26:27+00:00</published><updated>2024-09-10T14:26:27+00:00</updated><id>https://yuxqiu.github.io/blog/2024/zkp-lec-1</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2024/zkp-lec-1/"><![CDATA[<p>This is a supplement to <a href="https://www.youtube.com/watch?v=uchjTIlPzFo">Zero Knowledge Proofs - Lecture 1</a>.</p> <h2 id="not-all-interactive-protocols-can-be-converted-to-non-interactive-protocols">Not all interactive protocols can be converted to non-interactive protocols</h2> <p>In the lecture, the professor claimed that not all interactive protocols can be converted to non-interactive protocols, and the reason given in the <a href="https://zk-learning.org/assets/Lecture1-2023-slides.pdf?slide=72">slide</a> was that IP = AM sometimes requires a super-polynomial prover, and in the case of Fiat-Shamir transformation, the prover needs to be computationally bounded, and therefore cannot invert H.</p> <p>However, why is this the case? Let’s use Schnorr’s Protocol as a case study to explain it.</p> <h3 id="schnorrs-protocol">Schnorr’s Protocol</h3> <p>Goal: Prover convinces Verifier that they know $x$ such that $h = g^x$ where $g$ is a generator of a group.</p> \[\newcommand{\work}[2]{#1 &amp; &amp; #2\\} \newcommand{\varprover}{\class{var var_Prover}{\text{Prover}}} \newcommand{\varverifier}{\class{var var_Verifier}{\text{Verifier}}} \newcommand{\alicework}[1]{#1 &amp; &amp;\\[-5pt]} \newcommand{\samplezqs}[1]{\class{hover}{#1\sampleSymb\zqs}} \newcommand{\varr}{\class{var var_r}{r}} \require{action} \newcommand{\sampleSymb}{ {\; \xleftarrow{$} \;} } \newcommand{\zqs}{\mathbb{Z}_q^\ast} \newcommand{\varu}{\class{var var_u}{u}} \newcommand{\varg}{\class{var var_g}{g}} \newcommand{\alicebob}[3]{#1 &amp; \ra{#2} &amp; #3\\[-5pt]} \newcommand{\ra}[1]{\vphantom{}\smash{\xrightarrow{\hspace{1cm}#1\hspace{1cm}}}} \newcommand{\bobwork}[1]{ &amp; &amp; #1\\[-5pt]} \newcommand{\schnorrvalidate}{\mathsf{schnorr}\_\mathsf{validate}} \newcommand{\varh}{\class{var var_h}{h}} \newcommand{\bobseparator}{&amp;&amp;-------\\} \newcommand{\sample}[1]{#1\sampleSymb\zq} \newcommand{\varc}{\class{var var_c}{c}} \newcommand{\bobalice}[3]{#1 &amp; \la{#2} &amp; #3\\[-5pt]} \newcommand{\la}[1]{\vphantom{}\smash{\xleftarrow{\hspace{1cm}#1\hspace{1cm}}}} \newcommand{\varx}{\class{var var_x}{x}} \newcommand{\varz}{\class{var var_z}{z}} \newcommand{\equalQ}{\overset{?}{=}} \newcommand{\zq}{\mathbb{Z}_\varq} \newcommand{\varq}{\class{var var_q}{q}} \begin{array}{c} \work{\varprover}{\varverifier} \alicework{\samplezqs{\varr}} \alicework{\varu = \varg^\varr} \alicebob{}{\varu}{} \bobwork{\sample{\varc}} \bobalice{}{\varc}{} \alicework{\varz = \varr + \varx\cdot \varc} \alicebob{}{\varz}{} \bobwork{\varg^{\varz} \equalQ \varu \cdot \varh^\varc } \end{array}\] <ul> <li>Thanks <a href="https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/schnorr/">ZKDocs - Schnorr’s identification protocol</a> and <a href="https://crypto.stanford.edu/cs355/19sp/lec5.pdf">Lecture 5: Proofs of Knowledge, Schnorr’s protocol, NIZK</a> for providing the code and the graph.</li> </ul> <p>The completeness of the above protocol is easy to see. For soundness, instead of proving statistical soundness, we can prove <a href="https://crypto.stanford.edu/cs355/19sp/lec5.pdf?slide=3">special soundness</a>.</p> <p>Just a sidenote, to convert this Schnorr’s Protocol to an non-interactive version, <a href="https://www.zkdocs.com/docs/zkdocs/protocol-primitives/fiat-shamir/#what-can-go-wrong">ZKDocs</a> provides a case where incorrect input is used in Fiat-Shamir transformation, which causes the protocol to be insecure. It’s worth noting that the case they discussed is a bit different from what I have shown above. It’s about generating a valid triple ($X=g^x \pmod q$, $c = \text{Hash(input)}$, $z$) for any X of prover’s choice <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, which means there is no fixed $X$ shared by both parties at the beginning. If you are interested, feel free to read the linked article and the paper.</p> <h3 id="what-prevents-grinding">What prevents grinding?</h3> <p>Now, let’s get back to the protocol that I described above. Suppose we want to turn it into an non-interactive version. The obvious thing we can do is to let $c = \text{Hash(u)}$ and then use it to generate $z = r + x * c$.</p> <p>Now, you might be thinking: what prevents a malicious prover from grinding? In other words, since the variable $c$ is just a coin <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, the malicious prover can just sampled 2 $r$ and it’s very likely that one of the $\text{Hash(u)} = \text{Hash(g^r)}$ it gets is $0$, which means it can then return $z = r$ directly. From the perspective of the verifier, this is a correct proof.</p> <p>The answer to that problem is also very simple: c is not a coin, but a random value drawn from a field. If this is the case, the challenge space $C$ (the field where the “coin” c is chosen from) will be pretty large. As a result, the probability of finding the collision that I described above will be $\frac{1}{|C|}$ <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p> <ul> <li>If you treat $c$ as a $c$-bit number, then the probability will be $\frac{1}{|2^c|}$.</li> </ul> <h3 id="why-cant-all-interactive-protocols-be-converted-to-non-interactive-protocols-via-arthur-merlin-game">Why can’t all interactive protocols be converted to non-interactive protocols (via Arthur-Merlin Game)?</h3> <p>By the analysis above, we know that the probability of successfully grinding is $\frac{1}{2^c}$. If the prover is computationally bounded, this is fine. However, if it’s not the case, we are in trouble.</p> <p>This is exactly why not all interactive protocols can be converted to non-interactive protocols as IP = AM transformation sometimes requires extra <strong>super-polynomial</strong> powers from Merlin (the prover).</p> <h2 id="graph-non-isomorphism">Graph Non-Isomorphism</h2> <p>In the lecture, the professor shows an interactive proof of graph non-isomorphism. However, this proof is not ZK because <strong>a malicious verifier</strong> can use a completely new graph (not derived from either G0 or G1) and ask prover to show whether it is isomorphism to G0 or G1. Therefore, it can obtain extra information that cannot be simulated.</p> <p>The way to solve this problem is briefly discussed: the verifier first prove to the prover that the graph it sends (let’s call it G) is indeed isomorphic to one of the G0 and G1 (can be both).</p> <ul> <li>But it is indeed very tricky to do so if you think about this carefully. How can you prove this without revealing which graph is isomorphic to G?</li> </ul> <p>The remaining part of this article will analyze <a href="https://pinkpurplepineapples.wordpress.com/2019/07/24/zero-knowledge-proofs-graph-isomorphism/">this amazing blog</a> to see how we can prove this in a PZK (perfect zero knowledge) way.</p> <h3 id="solution-1">Solution 1</h3> <blockquote> <p>Send the two graphs $\pi_0(G_0), \pi_1(G_1)$. The verifier then sends back an integer, pointing to one of these two graphs, and the prover responds by providing the permutation from G to this graph. Note that if at least one of the graphs is isomorphic to G, the prover can do so with at least probability 1/2.</p> </blockquote> <p>This does not work because a simulator $S$, given access to verifier $V$, cannot simulate this because</p> <ul> <li>It runs in PPT (probabilistic polynomial time), so it cannot using $\pi_0(G_0), \pi_1(G_1)$ (where $\pi_0, \pi_1$ are random permutations), generating a random number $r$, checking if it is able to find a permutation between $G_r$ and $G$.</li> <li>At the same time, it does not know which graph $G$ is isomorphic to, so it pre-prepare a permutation $\pi$ and generate messages like $\pi(G), \pi_1(G_1)$ and $\pi_0(G_0), \pi(G)$.</li> </ul> <h3 id="solution-2">Solution 2</h3> <p>The prover sends back $\pi(G), \pi_0(G_0), \pi_1(G_1)$ in a random order. The verifier then randomly points to one of the three graphs, and asks the prover to show that this graph is isomorphic to G.</p> <p>For the same reason, this method doesn’t work either. Given the length of the article, I’ll skip to the last solution.</p> <h3 id="last-solution">Last Solution</h3> <p>The last solution is a very interesting construction.</p> <blockquote> <ol> <li>Prover responds by sending two scrambled and permuted ordered copies of G, G_0, G_1 to the Verifier, with an additional restriction that second scrambling of the three graphs is either a right shift, or a left shift of the original three graphs. <ul> <li>In other words, it sends: <ul> <li>$\pi(H), \pi_0(H_0), \pi_1(H_1)$</li> <li>$\pi_0’(H_0), \pi_1’(H_1), \pi’(H)$</li> </ul> </li> </ul> <ul> <li>or: <ul> <li>$\pi(H), \pi_0(H_0), \pi_1(H_1)$</li> <li>$\pi_1’(H_1), \pi’(H), \pi_0’(H_0)$</li> </ul> </li> <li>where $H, H_0, H_1$ is some random permutation (<strong>ordering</strong>) of $G, G_0, G_1$</li> </ul> </li> <li>The Verifier now responds with either a 0, or a 1, one option to continue with the proof, and the other to verify that the two permuted copies indeed satisfy the requirements.</li> <li>If the Verifier sent a 0, the Prover reveals the two permutations, and we go back to step 2. If the Verifier sent a 1, we continue to prove that at least one of the graphs is isomorphic to G, by choosing one of the columns, and showing that both of the graphs in that column are isomorphic to G by sending back the permutations.</li> </ol> </blockquote> <p>This solution works and achieve PZK because:</p> <ul> <li>H0, H1, H2 is a permutation of G0, G1, G2 (they are G0, G1, G2 in random order) -&gt; this ensures that the correct column that the prover will pick can be any of the three columns. <ul> <li>Suppose no permutation is used, and only left and right shifts are used. Then, the probability of a column being selected is 1:1:0 (G isomorphic to G0) or 1:0:1 (to G1) or 1:1:1 (to G0 and G1) depending on which graph G is isomorphic to. <ul> <li>Isomorphic to G0 <ul> <li><strong>G</strong>, G0, G1</li> <li><strong>G0</strong>, G1, G</li> <li> <hr/> </li> <li>G, <strong>G0</strong>, G1</li> <li>G1, <strong>G</strong>, G0</li> </ul> </li> <li>Isomorphic to G1 <ul> <li>G, G0, <strong>G1</strong></li> <li>G0, G1, <strong>G</strong></li> <li> <hr/> </li> <li><strong>G</strong>, G0, G1</li> <li><strong>G1</strong>, G, G0</li> </ul> </li> <li>So, without permutation, we can know some additional information based on which column is selected.</li> </ul> </li> </ul> </li> <li>Left Shift or Right Shift: it’s important to have them as well. This ensures that no matter the permutation, the distance between the G and G0/G1 (the graph G is isomorphic to) is always 1. If the distance is not always the same, after randomly selecting the column in the simulator, we cannot construct the other two columns randomly because we must fix the position of the graph that G is isomorphic to match distance = 1. <ul> <li>For example, given this permutation Gx, G, Gy. Suppose G1 is isomorphic to G. If we only allow left shift, we can only choose Gy as the position for G1. <ul> <li>But, in reality, the simulator doesn’t know which graph G is isomorphic to.</li> <li>So, after selecting the column randomly, it cannot proceed.</li> </ul> </li> </ul> </li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://eprint.iacr.org/2016/771.pdf#page=6">https://eprint.iacr.org/2016/771.pdf#page=6</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>This is not true, but a misconception that I had after listening to lecture 1. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p><a href="https://crypto.stackexchange.com/questions/97735/grinding-in-the-fiat-shamir-heuristic">https://crypto.stackexchange.com/questions/97735/grinding-in-the-fiat-shamir-heuristic</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="ZKP"/><category term="Applied Cryptography"/><summary type="html"><![CDATA[This is a supplement to Zero Knowledge Proofs - Lecture 1.]]></summary></entry><entry><title type="html">Implement a ThreadPool in C++ from Scratch</title><link href="https://yuxqiu.github.io/blog/2023/threadpool/" rel="alternate" type="text/html" title="Implement a ThreadPool in C++ from Scratch"/><published>2023-01-13T18:20:23+00:00</published><updated>2023-01-13T18:20:23+00:00</updated><id>https://yuxqiu.github.io/blog/2023/threadpool</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2023/threadpool/"><![CDATA[<h2 id="prerequisite">Prerequisite</h2> <p>Before reading this article, make sure you have basic understandings of the following concepts:</p> <ol> <li><code class="language-plaintext highlighter-rouge">std::thread</code>: how to create a thread, how to deal with a running thread, how the parameters are used in thread constructor</li> <li><code class="language-plaintext highlighter-rouge">std::mutex</code>, <code class="language-plaintext highlighter-rouge">std::lock_guard</code>, <code class="language-plaintext highlighter-rouge">std::unique_lock</code>: the differences between those three and the benefits of the later two</li> <li><code class="language-plaintext highlighter-rouge">std::condition_variable</code>:</li> <li><code class="language-plaintext highlighter-rouge">std::future</code>, <code class="language-plaintext highlighter-rouge">std::promise</code>: the relation between a <code class="language-plaintext highlighter-rouge">future</code> and a <code class="language-plaintext highlighter-rouge">promise</code>, how to construct them, can they be copied/moved constructed/assigned, the mechanisms behind <code class="language-plaintext highlighter-rouge">std::future</code> and <code class="language-plaintext highlighter-rouge">std::promise</code></li> <li><code class="language-plaintext highlighter-rouge">std::function</code>: what is it, mechanisms of type erasure</li> <li><code class="language-plaintext highlighter-rouge">std::move</code>, <code class="language-plaintext highlighter-rouge">std::forward</code>: move semantics, universal reference, perfect forwarding</li> <li>meta-programming: understand <code class="language-plaintext highlighter-rouge">if constexpr</code>, have basic ideas of type_traits</li> </ol> <h2 id="overview">Overview</h2> <p>Last night, I read an article in which a guy talked about how to implement a ThreadPool in C++. However, I wasn’t happy with his implementation because he used some unnecessary dynamic memory allocation: 1 for <code class="language-plaintext highlighter-rouge">package_task</code> with <code class="language-plaintext highlighter-rouge">shared_ptr</code>, 1 for the mechanisms behind <code class="language-plaintext highlighter-rouge">std::future</code> (unavoidable), 2 for a list of threads and a list of tasks (unavoidable), 1 for every <code class="language-plaintext highlighter-rouge">std::function</code> used (unavoidable) and etc. The one that I really want to get rid of is the allocation for <code class="language-plaintext highlighter-rouge">package_task</code>. Considering I have never made a thread pool in C++, I decide to write it today.</p> <p>So my goal for this thread pool is:</p> <ul> <li>use dynamic memory allocation as little as possible</li> <li>the supported version of C++ needs to be as low as possible (ideally C++11)</li> <li>the implementation needs to be as simple as possible</li> </ul> <p>And, for the thread pool, it should at least support these APIs:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ThreadPool(std::size_t n)</code>: construct <code class="language-plaintext highlighter-rouge">n</code> threads for the thread pool</li> <li><code class="language-plaintext highlighter-rouge">Stop</code>: stops the thread pool immediately, regardless of whether there are any outstanding tasks in the queue.</li> <li><code class="language-plaintext highlighter-rouge">Enqueue</code>: push a task into the task list</li> <li><code class="language-plaintext highlighter-rouge">~ThreadPool</code>: if the thread pool is not stopped, call <code class="language-plaintext highlighter-rouge">Stop</code></li> <li>Cannot be copied/moved constructed/assigned</li> </ul> <p>My ideas about how to implement this thread pool:</p> <ol> <li>a thread pool with the specified number of threads is initialized</li> <li>these threads will wait (mutex, condition_variable) until a task appears in the queue <ol> <li>if notified, execute the task</li> <li>acquire a new task after finishing</li> <li>if there is no more task, wait</li> </ol> </li> <li>users can enqueue task into the list (mutex, function, promise, future, lambda) <ol> <li>user’s function will be encapsulated with parameters together to form a new callable</li> <li>the callable will be stored inside <code class="language-plaintext highlighter-rouge">std::function</code></li> </ol> </li> </ol> <h2 id="challenges">Challenges</h2> <p>However, when I started to implement it, many problems suddenly appeared.</p> <h3 id="get-return-type-of-a-callable">Get Return Type of a Callable</h3> <p>The first question is how to correctly resolve the return type?</p> <p>First, we need a return type for the <code class="language-plaintext highlighter-rouge">Enqueue</code> function since we need to have a template argument for <code class="language-plaintext highlighter-rouge">std::future</code>. We can easily solve this by using automatic return type deduction introduced in C++14 (just use <code class="language-plaintext highlighter-rouge">auto</code> for the return type).</p> <p>Then, as we are dealing with a callable type, which can be a lambda, a function pointer or an object with overloaded <code class="language-plaintext highlighter-rouge">operator()</code>, we need a generic way to get its return type. That’s the use case of <code class="language-plaintext highlighter-rouge">std::invoke_result</code>. By passing the type of the callable and the type of the arguments, we can easily get the returned type from it. This is introduced since C++17.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// an example of std::invoke_result</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="c1">// other code</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="variadic-lambda">Variadic Lambda?</h3> <p>After solving the previous problem, we get another one: how to create a variadic lambda?</p> <p>The reason we need a lambda is that we need to encapsulate the callable from the user inside our callable, so that we could set the value of the <code class="language-plaintext highlighter-rouge">promise</code> when the task is executed. However, in order to encapsulate the user’s task inside our lambda, we need a lambda that can capture variadic parameters because the <code class="language-plaintext highlighter-rouge">Args</code> are variadic. Fortunately, this is a feature that is introduced in C++20.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// an example of variadic lambda</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="p">[...</span><span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)](){</span>
        <span class="c1">// code inside</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, it seems that we have gone too far from our second goal. Do we really need a lambda that captures variadic arguments?</p> <p>Since eventually, we need to store all the parameters into our task object (otherwise, we may not be able to support temporary value and may access objects after their lifetime), it’s reasonable to use <code class="language-plaintext highlighter-rouge">std::bind</code> instead of a lambda that captures variadic arguments. Also, it’s worth mentioning that <code class="language-plaintext highlighter-rouge">std::bind</code> is introduced in C++11.</p> <p>So, we finally have a solution:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="nolint">NOLINT</h3> <p>As I am using clang-tidy with some very “harsh” rules, it immediately gives me a warning for the use of <code class="language-plaintext highlighter-rouge">std::bind</code>. It reminds me to use lambda instead of <code class="language-plaintext highlighter-rouge">std::bind</code>. So, I need a way to bypass the linter. That’s the usage of <code class="language-plaintext highlighter-rouge">NOLINT</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a_new_callable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span> <span class="c1">// NOLINT</span>
</code></pre></div></div> <h3 id="move-only-function">move-only-function</h3> <p>Things don’t go well as expected. It seems that I understand why people use an additional dynamic memory allocation for the <code class="language-plaintext highlighter-rouge">std::promise</code> or the <code class="language-plaintext highlighter-rouge">std::package_task</code>. It’s because these two types are not copyable.</p> <p>The fact that they are not copyable causes a huge problem when we want to construct a <code class="language-plaintext highlighter-rouge">std::function</code> by using a lambda that captures them. Because they are not copyable, the resulting lambda is also not copyable. However, <code class="language-plaintext highlighter-rouge">std::function</code> is supposed to be copyable, and it has a copy constructor. Therefore, we fail to instantiate the template.</p> <p>The solution to this problem is to use something called <code class="language-plaintext highlighter-rouge">std::move_only_function</code> introduced in C++23 (Thanks Jason Turner! I know this because I watched your video). Compared with the <code class="language-plaintext highlighter-rouge">std::function</code>, <code class="language-plaintext highlighter-rouge">std::move_only_function</code>, as its name suggests, can only be moved. Therefore, we could safely capture movable object in our lambda.</p> <p>However, it’s a C++23 feature, and I don’t want the user of my thread pool to install a <code class="language-plaintext highlighter-rouge">trunk</code> compiler just for the <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. So, I decide to provide a very naive implementation for <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. But people who can use <code class="language-plaintext highlighter-rouge">c++2b</code> should definitely use their <code class="language-plaintext highlighter-rouge">std::move_only_function</code>. Therefore, I decide to use feature-test macro to help me do this.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef __cpp_lib_move_only_function
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">MoveOnlyFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move_only_function</span><span class="o">&lt;</span><span class="n">Signature</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#else
</span>  <span class="c1">// My MoveOnlyFunction here</span>
<span class="cp">#endif
</span></code></pre></div></div> <p>To understand how to implement the <code class="language-plaintext highlighter-rouge">std::move_only_function</code>, I recommend you to watch this great talk <a href="https://www.youtube.com/watch?v=tbUCHifyT24">Back to Basics: Type Erasure - Arthur O’Dwyer - CppCon 2019</a> by Arthur. You will learn what affordances are, how to implement hand-crafted type-erased classes, and how to rely on the v-table mechanism to implement type-erased classes.</p> <p>This is my naive implementation of <code class="language-plaintext highlighter-rouge">std::move_only_function</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">private:</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Callable</span> <span class="n">func_</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">Derived</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="o">:</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="p">{}</span>
    <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="k">final</span> <span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">func_impl_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="k">explicit</span> <span class="n">MoveOnlyFunction</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
<span class="k">explicit</span> <span class="nf">MoveOnlyFunction</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="c1">// NOLINT</span>
    <span class="o">:</span> <span class="n">func_impl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;&gt;</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span> <span class="p">{}</span>

<span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">func_impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">,</span> <span class="n">func_impl_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">func_impl_</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>Do notice that there is a very interesting trick about taking <code class="language-plaintext highlighter-rouge">Signature</code> as a template argument here. I provide a partial specialization of the class to actually make the <code class="language-plaintext highlighter-rouge">Signature</code> trick work.</p> <h2 id="the-final-code">The final code</h2> <p>The final implementation looks like this:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
<span class="nl">private:</span>
<span class="cp">#ifdef __cpp_lib_move_only_function
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">MoveOnlyFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move_only_function</span><span class="o">&lt;</span><span class="n">Signature</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#else
</span>  <span class="c1">// A simple implementation of MoveOnlyFunction</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">MoveOnlyFunction</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="nl">public:</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="nl">private:</span>
      <span class="n">Callable</span> <span class="n">func_</span><span class="p">;</span>

    <span class="nl">public:</span>
      <span class="k">explicit</span> <span class="n">Derived</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="o">:</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="p">{}</span>
      <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="k">final</span> <span class="p">{</span>
        <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">func_impl_</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">MoveOnlyFunction</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="nf">MoveOnlyFunction</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span> <span class="c1">// NOLINT</span>
        <span class="o">:</span> <span class="n">func_impl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;&gt;</span><span class="p">(</span>
              <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span> <span class="p">{}</span>

    <span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">MoveOnlyFunction</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">func_impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">;</span>
      <span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveOnlyFunction</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">MoveOnlyFunction</span> <span class="o">&amp;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">func_impl_</span><span class="p">,</span> <span class="n">func_impl_</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ret</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">func_impl_</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="cp">#endif
</span>
  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">MoveOnlyFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">tasks_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock_</span><span class="p">{};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">{};</span>
  <span class="kt">bool</span> <span class="n">stopped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="nf">ThreadPool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">MoveOnlyFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{};</span> <span class="c1">// benchmark inside or outside</span>
          <span class="p">{</span>
            <span class="k">auto</span> <span class="n">ulock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lock_</span><span class="p">};</span>
            <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">ulock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">stopped_</span> <span class="o">||</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">tasks_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
            <span class="p">});</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">stopped_</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
            <span class="n">tasks_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="n">task</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">ThreadPool</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadPool</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">ThreadPool</span><span class="p">(</span><span class="n">ThreadPool</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ThreadPool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ThreadPool</span> <span class="o">&amp;</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
    <span class="n">stopped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="kr">thread</span> <span class="o">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">auto</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="n">Callable</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">Return_Type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Return_Type</span><span class="o">&gt;</span><span class="p">{};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lock_</span><span class="p">};</span>
      <span class="n">tasks_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
          <span class="p">[</span><span class="n">promise</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">promise</span><span class="p">),</span>
           <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)]()</span> <span class="k">mutable</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">Return_Type</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
              <span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
            <span class="p">}</span>
          <span class="p">});</span>
    <span class="p">}</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">future</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="benchmark">Benchmark</h2> <p>I create a simple benchmark for my implementation. I compare it with one of the most famous <a href="https://github.com/bshoshany/thread-pool">implementation</a> in Github.</p> <p>The benchmark code is something like this:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Timer</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_start_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">())</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">Timer</span><span class="p">()</span> <span class="p">{</span> <span class="n">Stop</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_start_</span><span class="p">)</span>
            <span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()</span>
            <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">stop</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
            <span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()</span>
            <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Duration: "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span> <span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span> <span class="n">m_start_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">auto</span> <span class="n">Worker</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ThreadPoolTest</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// different thread pool is used here</span>
  <span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()};</span>
  <span class="n">Timer</span> <span class="n">timer</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">result</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">Worker</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">future</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span>
  <span class="n">ThreadPoolTest</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>I have plotted a graph for the benchmark results and it looks very good. (All the code are compiled with <code class="language-plaintext highlighter-rouge">-Ofast</code>).</p> <p><img src="/assets/img/blog/2023/01/threadpool-benchmark.svg" alt="benchmark"/></p> <p>By using <code class="language-plaintext highlighter-rouge">hyperfine</code>, I am able to get the following result</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Benchmark 1: ./bench (my thread pool)
  Time (mean ± σ):     11.814 s ±  0.366 s    [User: 81.934 s, System: 1.862 s]
  Range (min … max):   11.410 s … 12.335 s    10 runs

Benchmark 2: ./bench-bs (bs thread pool light)
  Time (mean ± σ):     12.680 s ±  0.061 s    [User: 88.338 s, System: 1.866 s]
  Range (min … max):   12.578 s … 12.766 s    10 runs

Summary
  './bench' ran
    1.07 ± 0.03 times faster than './bench-bs'
</code></pre></div></div> <p>So, it’s roughly 1.1 times faster than bs’s implementation.</p> <h2 id="improvements">Improvements</h2> <p>There are certainly many rooms for improvements.</p> <ol> <li> <p>One can argue that the API is far less than enough as it provides no way to inspect the number of tasks and threads. In addition, there is not enough customisability: the user cannot decide how to start the thread (in detached mode or joined mode).</p> </li> <li> <p>The task queue can be implemented via some lock-free mechanisms. To further reduce the contention, we can even create a queue for every thread and implement work-stealing mechanism.</p> </li> <li> <p>Possible optimizations of <code class="language-plaintext highlighter-rouge">MoveOnlyFunction</code>. For <code class="language-plaintext highlighter-rouge">std::string</code>, we have something called Small String Optimization (SSO). The same solution exists for <code class="language-plaintext highlighter-rouge">std::function</code>, which is known as Small Function Optimization (SFO). We can apply this to <code class="language-plaintext highlighter-rouge">MoveOnlyFunction</code> to save us one dynamic memory allocation for small callable objects.</p> </li> <li> <p>Exception guarantee. Currently, we neglect the exception guarantee provided by the user. We should take this into account when packaging user’s callable and arguments into a task.</p> </li> </ol> <h2 id="what-i-learned">What I learned</h2> <ol> <li><code class="language-plaintext highlighter-rouge">std::invoke_result</code></li> <li>lambda that captures variadic arguments</li> <li><code class="language-plaintext highlighter-rouge">std::move_only_function</code></li> <li>more about lambda captures <ol> <li><a href="https://stackoverflow.com/questions/3772867/lambda-capture-as-const-reference">Lambda capture as const reference?</a></li> </ol> </li> <li>type-erased class in practice</li> <li>meta-programming in practice <ol> <li>perfect forwarding</li> <li><code class="language-plaintext highlighter-rouge">if constexpr</code></li> <li>type traits</li> </ol> </li> </ol>]]></content><author><name></name></author><category term="cpp"/><category term="concurrency"/><summary type="html"><![CDATA[Prerequisite]]></summary></entry><entry><title type="html">TIL-6</title><link href="https://yuxqiu.github.io/blog/2023/til-6/" rel="alternate" type="text/html" title="TIL-6"/><published>2023-01-07T19:42:06+00:00</published><updated>2023-01-07T19:42:06+00:00</updated><id>https://yuxqiu.github.io/blog/2023/til-6</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2023/til-6/"><![CDATA[<h2 id="why-does-calloc-exist"><a href="https://vorpus.org/blog/why-does-calloc-exist/">Why does calloc exist?</a></h2> <p>Explain the reasoning behind the <code class="language-plaintext highlighter-rouge">calloc</code> function in C. The use of <code class="language-plaintext highlighter-rouge">calloc</code> ensures the allocated memory is zeroed. Compared with the <code class="language-plaintext highlighter-rouge">malloc</code> + <code class="language-plaintext highlighter-rouge">memset</code> method, <code class="language-plaintext highlighter-rouge">calloc</code> offers overflow checking and is more efficient than the <code class="language-plaintext highlighter-rouge">malloc</code> because it relies on the fact that 1) new memory returned from OS is zeroed and 2) the actual memory allocation (page fault) is delayed until the application starts to access the memory.</p> <h2 id="c-standard-parallelism"><a href="https://www.youtube.com/watch?v=LW_T2RGXego">C++ Standard Parallelism</a></h2> <p><img src="/assets/img/blog/2023/01/til-6-par-word-count.png" alt=""/></p> <p>It reminds me of certain ways to implement an efficient <code class="language-plaintext highlighter-rouge">wc</code>. Given a <code class="language-plaintext highlighter-rouge">std::string content</code>,</p> <ul> <li>to count the number of chars, simply call <code class="language-plaintext highlighter-rouge">content.size()</code>;</li> <li>to count the number of words, use the algorithm above;</li> <li>to count the number of lines, use <code class="language-plaintext highlighter-rouge">std::count</code> with <code class="language-plaintext highlighter-rouge">par_unseq</code></li> </ul> <p>My mental model for</p> <ul> <li><code class="language-plaintext highlighter-rouge">seq</code>: normal sequential program</li> <li><code class="language-plaintext highlighter-rouge">unseq</code>: SIMD instructions</li> <li><code class="language-plaintext highlighter-rouge">par</code>: multithreading</li> <li><code class="language-plaintext highlighter-rouge">par_unseq</code>: multithreading with SIMD instructions</li> </ul> <h2 id="empty-base-optimization"><a href="https://en.cppreference.com/w/cpp/language/ebo">Empty Base Optimization</a></h2> <p>Why Empty class requires to have one byte? It’s worth remembering that in C++, “the addresses of distinct objects of the same type are always distinct”.</p> <ul> <li>At first glance, it makes no sense that we can have two objects of the same type that are in the same address.</li> <li>But this rule is relaxed in C++20 to further promote EBO</li> </ul> <p>When can we apply <code class="language-plaintext highlighter-rouge">[[no_unique_address]]</code>? We use it typically when we need to put some empty class inside some classes.</p> <p>EBO application: <code class="language-plaintext highlighter-rouge">std::pair</code> (reduce the size of the pair), any allocator-awarded container (avoid some extra bytes caused by the storage of the allocator).</p> <p>A corner case of EBO:</p> <blockquote> <p>Empty base optimization is prohibited if one of the empty base classes is also the type or the base of the type of the first non-static data member, since the two base subobjects of the same type are required to have different addresses within the object representation of the most derived type.</p> </blockquote> <h2 id="trivia">Trivia</h2> <ul> <li>Discussions about <code class="language-plaintext highlighter-rouge">TCP_NODELAY</code> <ul> <li><a href="https://withinboredom.info/blog/2022/12/29/golang-is-evil-on-shitty-networks/">Golang is evil on shitty networks</a></li> <li><a href="http://rachelbythebay.com/w/2023/01/05/syscall/">Spammy syscalls in strace dumps</a></li> </ul> </li> <li>Pipe mechanism <ul> <li><a href="https://unix.stackexchange.com/questions/409827/pipeline-as-parallel-command">Pipeline as parallel command</a></li> <li>When the second application (receiver) exits while the first application (sender) still writes to the pipe, we get broken pipe (SIGPIPE)</li> <li><a href="https://unix.stackexchange.com/questions/84813/what-makes-a-unix-process-die-with-broken-pipe">A typical example of SIGPIPE</a></li> </ul> </li> <li>Recursive Lambda in C++ <ul> <li><a href="https://youtu.be/Wg1f9Sufyic?t=3145">The Surprising Costs of void() (and Other Not-Quite-Innocuous Evils)</a></li> <li>We cannot capture lambda itself when creating the lambda. Neither by value or by reference will work. By value definitely cannot work due to recursive definition. By reference has the potential to work, but as we cannot during the type of the lambda when capturing it, it doesn’t work.</li> <li>There are two solutions to build a recursive lambda. The first one is to take another <code class="language-plaintext highlighter-rouge">auto</code> parameter which we will use to accept lambda. The second one is to use declare a variable with type <code class="language-plaintext highlighter-rouge">std::function</code>, which allows us to capture this variable when declaring lambda (as shown in video). However, we need to take care of its lifetime as we are capturing by reference here.</li> </ul> </li> <li><a href="https://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement">Why can’t variables be declared in a switch statement?</a> <ul> <li>Cases are just labels. (That’s why we could have tricks like Duff’s device).</li> <li>The best way to deal with them is to treat them as labels (like those in jump). We could avoid the uninitialization errors by using a <code class="language-plaintext highlighter-rouge">{}</code> bracket in each case (therefore, each case is not in the same scope).</li> </ul> </li> <li>Rust reference <ul> <li><a href="https://users.rust-lang.org/t/reference-to-a-reference/44753/2">Reference to a reference in Rust</a></li> <li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref trait and Deref coercion</a>. If we are passing reference of references, it will be automatically coerced.</li> <li><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">Index trait and []</a></li> </ul> </li> <li>The Blank Sheet <ul> <li><a href="https://fs.blog/reading/">Reading Better: Retaining and Applying What You Read</a></li> <li>Active reading.</li> </ul> </li> <li>Inline namespace <ul> <li><a href="https://www.youtube.com/watch?v=rUESOjhvLw0">C++ Weekly - Ep 320 - Using <code class="language-plaintext highlighter-rouge">inline namespace</code> To Save Your ABI</a></li> <li>How the object file is linked when we apply <code class="language-plaintext highlighter-rouge">inline namespace</code>: a call to <code class="language-plaintext highlighter-rouge">A::f</code> is linked to <code class="language-plaintext highlighter-rouge">A::inline_namespace_name::f</code></li> <li>Therefore, we could use different inline namespace names for different versions of our library. As a result of that, the ABI break will actually cause linker errors.</li> </ul> </li> <li><a href="https://stackoverflow.com/questions/31101854/order-of-destruction-for-stack-heap-allocated-arrays">Order of destruction for stack/heap allocated arrays</a> <ul> <li>The array elements will be destructed in reverse order of construction, with element 99 being the first destructed, then element 98, 97, 96… etc. and element 0 being the last.</li> <li>It’s reasonable once you think about how we declare variables in program order like this: <code class="language-plaintext highlighter-rouge">A a; B b; C c;</code>. The construction order is A, B, C, and the destruction order is C, B, A. This corresponds to how the array is constructed/destructed.</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="TIL"/><category term="c"/><category term="cpp"/><category term="rust"/><summary type="html"><![CDATA[Why does calloc exist?]]></summary></entry><entry><title type="html">Concurrency</title><link href="https://yuxqiu.github.io/blog/2022/concurrency/" rel="alternate" type="text/html" title="Concurrency"/><published>2022-12-08T20:39:06+00:00</published><updated>2022-12-08T20:39:06+00:00</updated><id>https://yuxqiu.github.io/blog/2022/concurrency</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/concurrency/"><![CDATA[<h2 id="java-memory-model">Java Memory Model</h2> <p>For an object to be safely shared across different threads (visibility), it needs to be</p> <ul> <li>immutable, which JVM guarantees all the fields initialized before constructor exits</li> <li>effective immutable + safely published</li> <li>mutable + safely published + synchronization mechanism</li> </ul> <h3 id="immutable-object-and-safe-publishing">Immutable Object and Safe Publishing</h3> <ol> <li> <p>Immutable = all the fields are marked with <code class="language-plaintext highlighter-rouge">final</code></p> </li> <li> <p>Safely published means</p> <ol> <li>The object is statically initialized</li> <li>The reference of the object is put into <code class="language-plaintext highlighter-rouge">final</code></li> <li>The reference of the object is put into <code class="language-plaintext highlighter-rouge">volatile</code>: all the writes to the object directly writes to the memory instead of staying in cache</li> <li>Storing a reference to it into a field that is properly guarded by a lock</li> </ol> </li> </ol> <h2 id="reordering-java-and-c">Reordering (Java and C++)</h2> <ol> <li>Instruction reordering is a useful technique for Instruction Level Parallelism. However, it causes problems when we are sharing multiple variables during concurrency. <ol> <li> <p>The classic example is shown below:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="kt">void</span> <span class="nf">thread1</span><span class="o">(){</span>
      <span class="n">val</span> <span class="o">=</span> <span class="mi">42</span><span class="o">;</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">thread2</span><span class="o">(){</span>
      <span class="k">while</span><span class="o">(!</span><span class="n">flag</span><span class="o">){}</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>It’s possible that the val printed is not equal to 42 because the instruction can be reordered such that flag is set to true before val is set to 42</p> </li> </ol> </li> <li>To address this in Java, we could use <code class="language-plaintext highlighter-rouge">volatile</code> on flag. It gives a “happens-before” guarantee in addition to the visibility guarantee. The happens-before guarantee guarantees that: <sup id="fnref:reordering-1" role="doc-noteref"><a href="#fn:reordering-1" class="footnote" rel="footnote">1</a></sup> <ol> <li><strong>Reads from and writes to other variables</strong> cannot be reordered to occur after a write to a volatile variable, if the reads / writes originally occurred before the write to the volatile variable.</li> <li>The reads / writes before a write to a volatile variable are guaranteed to “happen before” the write to the volatile variable. Notice that it is still possible for e.g. reads / writes of other variables located after a write to a volatile to be reordered to occur before that write to the volatile. Just not the other way around. From after to before is allowed, but from before to after is not allowed.</li> <li><strong>Reads from and writes to other variables cannot be reordered to occur before a read of a volatile variable</strong>, if the reads / writes originally occurred after the read of the volatile variable. Notice that it is possible for reads of other variables that occur before the read of a volatile variable can be reordered to occur after the read of the volatile. Just not the other way around.</li> </ol> </li> <li>C++’s <code class="language-plaintext highlighter-rouge">volatile</code> is different in terms of its guarantee. It says “volatile accesses cannot be optimized out or reordered with another visible side effect that is sequenced-before or sequenced-after the volatile access.” <sup id="fnref:reordering-2" role="doc-noteref"><a href="#fn:reordering-2" class="footnote" rel="footnote">2</a></sup> <ol> <li><a href="https://en.cppreference.com/w/cpp/language/as_if#Explanation">What is a visible side effect?</a></li> <li><a href="https://en.cppreference.com/w/cpp/language/eval_order#Rules">What is sequenced-before?</a></li> <li>So, consider the Java example in C++ context. We have different possibilities when we apply <code class="language-plaintext highlighter-rouge">volatile</code> to these two variables, see <a href="https://gcc.godbolt.org/z/hYM96r9r6">compiler explorer</a> (Notice, C++ <code class="language-plaintext highlighter-rouge">volatile</code> cannot be used to address the synchronization problem in this example.) <ol> <li>If both variables are non-volatile, they can be reordered</li> <li>If one of them are volatile, they can still be reordered (as the writes to another variable is not a visible side effect)</li> <li>If two of them are volatile, the order must be respected based on sequence-before rules</li> </ol> </li> </ol> </li> </ol> <h2 id="execution">Execution</h2> <h3 id="execution-within-one-thread">Execution within one thread</h3> <ol> <li>Java: “Each action in a thread happens-before every action in that thread that comes later in the program’s order.” <sup id="fnref:execution-1" role="doc-noteref"><a href="#fn:execution-1" class="footnote" rel="footnote">3</a></sup> <ol> <li> <blockquote> <p>It should be noted that the presence of a happens-before relationship between two actions does not necessarily imply that they have to take place in that order in an implementation. If the reordering produces results consistent with a legal execution, it is not illegal. <sup id="fnref:execution-2" role="doc-noteref"><a href="#fn:execution-2" class="footnote" rel="footnote">4</a></sup></p> </blockquote> </li> </ol> </li> <li>C++: “Each value computation and side effect of a full-expression is sequenced before each value computation and side effect of the next full-expression.” <sup id="fnref:execution-3" role="doc-noteref"><a href="#fn:execution-3" class="footnote" rel="footnote">5</a></sup> <ol> <li>as-if rule permits optimization. Those guarantees are the guarantees of C++ Abstract Machine.</li> </ol> </li> </ol> <h3 id="execution-with-multiple-threads">Execution with multiple threads</h3> <ol> <li><code class="language-plaintext highlighter-rouge">volatile</code> in Java can be used to ensure safe publishing</li> <li><code class="language-plaintext highlighter-rouge">volatile</code> in C++ <ol> <li> <blockquote> <p>Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. <sup id="fnref:execution-4" role="doc-noteref"><a href="#fn:execution-4" class="footnote" rel="footnote">6</a></sup></p> </blockquote> </li> <li>It’s mainly used to deal with signal handling</li> <li>It’s not intended to use for inter-thread communication (sequence-before is used to describe execution within one thread). Inter-thread communication should consider the memory fence or mutex.</li> <li>See <a href="https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive">guarantees not provided by volatile</a> for more details</li> </ol> </li> </ol> <h2 id="more-resources">More resources</h2> <ol> <li><a href="https://stackoverflow.com/questions/51695962/does-object-construction-guarantee-in-practice-that-all-threads-see-non-final-fi">An example of unsafe publishing</a></li> <li><a href="https://stackoverflow.com/questions/16107683/improper-publication-of-java-object-reference">Why unsafe publishing can occur?</a></li> <li><a href="https://stackoverflow.com/questions/4557979/when-to-use-volatile-with-multi-threading">When to use volatile with multi threading?</a></li> </ol> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:reordering-1" role="doc-endnote"> <p><a href="https://jenkov.com/tutorials/java-concurrency/volatile.html">Java Volatile Keyword</a> <a href="#fnref:reordering-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:reordering-2" role="doc-endnote"> <p><a href="https://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers</a> <a href="#fnref:reordering-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:execution-1" role="doc-endnote"> <p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility">Package java.util.concurrent: Memory Consistency Properties</a> <a href="#fnref:execution-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:execution-2" role="doc-endnote"> <p><a href="https://stackoverflow.com/a/32492873">JLS happens before</a> <a href="#fnref:execution-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:execution-3" role="doc-endnote"> <p><a href="https://en.cppreference.com/w/cpp/language/as_if#Explanation">Order of evaluation: "Sequenced before" rules</a> <a href="#fnref:execution-3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:execution-4" role="doc-endnote"> <p><a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Relationship_with_volatile">std::memory_order: Relationship with volatile</a> <a href="#fnref:execution-4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="concurrency"/><category term="cpp"/><category term="java"/><summary type="html"><![CDATA[Java Memory Model]]></summary></entry><entry><title type="html">Memcpy and Undefined Behavior</title><link href="https://yuxqiu.github.io/blog/2022/memcpy-union/" rel="alternate" type="text/html" title="Memcpy and Undefined Behavior"/><published>2022-12-05T09:05:17+00:00</published><updated>2022-12-05T09:05:17+00:00</updated><id>https://yuxqiu.github.io/blog/2022/memcpy-union</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/memcpy-union/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>The aim of this article is to provide an axiomatic way of understanding <code class="language-plaintext highlighter-rouge">memcpy</code> and the undefined behaviour associated with it.</p> <p>Before talking about the <code class="language-plaintext highlighter-rouge">memcpy</code>, it’s necessary to understand</p> <ul> <li>some basics about C++ Standard Library</li> <li>C++ class layout</li> <li>Strict Aliasing</li> </ul> <h2 id="c-standard-library">C++ Standard Library</h2> <blockquote> <p>[defns.undefined]: undefined behavior is behavior for which this document imposes no requirements</p> </blockquote> <blockquote> <p>[library.c]: The descriptions of many library functions rely on the C standard library for the semantics of those functions. In some cases, the signatures specified in this document may be different from the signatures in the C standard library, and additional overloads may be declared in this document, but the behavior and the preconditions (including any preconditions implied by the use of an ISO C restrict qualifier) are the same unless otherwise stated.</p> </blockquote> <h2 id="class-layout">Class Layout</h2> <blockquote> <p><a href="https://learn.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170">Trivial, standard-layout, POD, and literal types</a></p> </blockquote> <ol> <li>Trivial Types <ol> <li>Definition <ol> <li>no virtual functions or virtual base classes,</li> <li>no base classes with a corresponding non-trivial constructor/operator/destructor</li> <li>no data members of class type with a corresponding non-trivial constructor/operator/destructor</li> </ol> </li> <li>Notes <ol> <li>Trivial Types can have different access modifiers</li> <li>The C++ Standard places no requirements on the layout between different class modifiers. Compilers can feel free to optimize these (e.g. move private members to lower memory address even though they are declared after public members)</li> <li><a href="https://stackoverflow.com/a/52745420">Potential optimizations that can be done</a></li> </ol> </li> </ol> </li> <li>Standard layout types <ol> <li>no virtual functions or virtual base classes</li> <li>all non-static data members have the same access control</li> <li>all non-static members of class type are standard-layout</li> <li>any base classes are standard-layout</li> <li>has no base classes of the same type as the first non-static data member.</li> <li>meets one of these conditions: <ol> <li>no non-static data member in the most-derived class and no more than one base class with non-static data members, or</li> <li>has no base classes with non-static data members</li> </ol> </li> </ol> </li> <li>POD <ol> <li>Both Trivial and Standard Layout</li> </ol> </li> </ol> <h2 id="strict-aliasing">Strict Aliasing</h2> <blockquote> <p><a href="https://en.cppreference.com/w/cpp/language/object#Strict_aliasing">Strict Aliasing</a></p> <p><a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing">Type aliasing</a></p> </blockquote> <p>Whenever an attempt is made to <strong>read or modify</strong> the stored value of an object of type DynamicType through a glvalue of type AliasedType, the behavior is undefined unless one of the following is true:</p> <ul> <li>AliasedType and DynamicType are <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing">similar</a>.</li> <li>AliasedType is the (possibly cv-qualified) signed or unsigned variant of DynamicType.</li> <li>AliasedType is std::byte, (since C++17) char, or unsigned char: this permits examination of the object representation of any object as an array of bytes.</li> </ul> <p>More about Strict Aliasing</p> <ul> <li><a href="https://stackoverflow.com/a/98702">An intuitive way to understand strict aliasing</a></li> <li><a href="https://stackoverflow.com/a/18929285">Casting to void* and Casting back is perfectly defined</a></li> </ul> <h2 id="trap-representation">Trap Representation</h2> <ol> <li><a href="https://stackoverflow.com/questions/6725809/trap-representation/6725981#6725981">What is a trap representation</a></li> <li><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2091.htm#problem">What happens if we read a trap based on its type</a> <ol> <li>This applies as C++ (at least after 17) uses C11 as its normative references [intro.refs]</li> </ol> </li> <li><a href="https://en.cppreference.com/w/cpp/language/object#Object_representation_and_value_representation">Guarantee provided by C++ standard</a> <ol> <li>This is the best justification I can find: [basic.fundamental.7] Type char is a distinct type that has an implementation-defined choice of “signed char” or “unsigned char” as its underlying type. The values of type char can represent distinct codes for all members of the implementation’s basic character set. The three types char, signed char, and unsigned char are collectively called ordinary character types. The ordinary character types and <code class="language-plaintext highlighter-rouge">char8_t</code> are collectively called narrow character types. For narrow character types, each possible bit pattern of the object representation represents a distinct value.</li> </ol> </li> </ol> <h2 id="memcpy">Memcpy</h2> <p>So, what does the standard say about memcpy exactly? The standard mentions <code class="language-plaintext highlighter-rouge">std::memcpy</code> multiple times. But the quotes that cause many confusions is in [basic.types]:</p> <blockquote> <p>For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes (6.6.1) making up the object can be copied into an array of char, unsigned char, or std::byte (21.2.1). If the content of that array is copied back into the object, the object shall subsequently hold its original value. Example:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N sizeof(T)
</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">T</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// obj initialized to its original value</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span> <span class="c1">// between these two calls to std::memcpy, obj might be modified</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span> <span class="c1">// at this point, each subobject of obj of scalar type holds its original value</span>
</code></pre></div> </div> <p>For any trivially copyable type T, if two pointers to T point to distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a base-class subobject, if the underlying bytes (6.6.1) making up obj1 are copied into obj2, obj2 shall subsequently hold the same value as obj1. Example:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="o">*</span> <span class="n">t1p</span><span class="p">;</span>
<span class="n">T</span><span class="o">*</span> <span class="n">t2p</span><span class="p">;</span>
<span class="c1">// provided that t2p points to an initialized object ...</span>
<span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">t1p</span><span class="p">,</span> <span class="n">t2p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
<span class="c1">// at this point, every subobject of trivially copyable type in *t1p contains</span>
<span class="c1">// the same value as the corresponding subobject in *t2p</span>
</code></pre></div> </div> </blockquote> <p>Here, the standard lists two ways that are perfectly defined: we can copy to buffers of narrow character type and restore the object, or we can directly copy into another object of the same type. Some people believe that based on “[defns.undefined]”, other uses of <code class="language-plaintext highlighter-rouge">memcpy</code> are not properly defined.</p> <p>However, this is the time we need to directly refer to the <code class="language-plaintext highlighter-rouge">memcpy</code>. The C++ standard states that</p> <ul> <li>If the objects are potentially-overlapping or not TriviallyCopyable, the behavior of <code class="language-plaintext highlighter-rouge">memcpy</code> is not specified and may be undefined. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li> <li>Plus all the things stated by C standard (My Point) <ul> <li>Based on “[library.c]”</li> </ul> </li> </ul> <p>So far, it looks like we have solid grounds to use <code class="language-plaintext highlighter-rouge">memcpy</code> in C++ as long as we are manipulating Trivially Copyable Types. However, some people mention about the trap, claiming that it’s undefined behavior if we try to access the value based on the type that has trap representation. So, they believe it’s not safe to copy from a type <code class="language-plaintext highlighter-rouge">T</code> to a type <code class="language-plaintext highlighter-rouge">U</code> unless <code class="language-plaintext highlighter-rouge">U</code> is of narrow character types or <code class="language-plaintext highlighter-rouge">U == T</code> (given that the destination has enough size for the src). <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p> <p>However, my point is <code class="language-plaintext highlighter-rouge">memcpy</code> is noy affected by the existence of trap representation because as the standard explicitly stated in <code class="language-plaintext highlighter-rouge">std::memcpy</code>: “both objects (the src and dest pointers) are reinterpreted as arrays of unsigned char.” Since we are not accessing the object of Type <code class="language-plaintext highlighter-rouge">U</code> via the type <code class="language-plaintext highlighter-rouge">U</code> itself, we are in the safe realm.</p> <p>So, in summary, given the requirements about “size”, “not overlapping”, “trivially copyable”, we can:</p> <ul> <li>Copy some bytes into some buffer (don’t necessarily need to be narrow character types or the types of the src object)</li> <li>Restore an object by copying from some buffer to the storage of the object</li> </ul> <hr/> <p>Note-1: <code class="language-plaintext highlighter-rouge">memcpy</code> for Standard Layout Types:</p> <ul> <li><a href="https://stackoverflow.com/questions/52871481/can-i-memcpy-objects-data-which-has-standard-layout-compatible-class-in-c11">Why is the behavior of memcpy unspecified, and probably undefined for standard layout types - 1</a></li> <li><a href="https://stackoverflow.com/questions/29777492/why-would-the-behavior-of-stdmemcpy-be-undefined-for-objects-that-are-not-triv">Why is the behavior of memcpy unspecified, and probably undefined for standard layout types - 2</a></li> </ul> <h2 id="some-discussions-about-union">Some discussions about Union</h2> <ol> <li><a href="https://adriann.github.io/undefined_behavior.html">Union is Undefined Behavior</a></li> <li><a href="https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-and-undefined-behavior">Accessing inactive union member and undefined behavior?</a></li> </ol> <h2 id="open-questions">Open Questions</h2> <ul> <li>Are undefined behaviors always bad? Why don’t we make some of UB as implementations defined behaviors?</li> <li>How should we interpret the C++ standard?</li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://en.cppreference.com/w/cpp/string/byte/memcpy">std::memcpy</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="https://stackoverflow.com/questions/51300626/is-stdmemcpy-between-different-trivially-copyable-types-undefined-behavior/">Is std::memcpy between different trivially copyable types undefined behavior?</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="cpp"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">TIL-5: Singleton, Fuzzing and Trivia</title><link href="https://yuxqiu.github.io/blog/2022/til-5/" rel="alternate" type="text/html" title="TIL-5: Singleton, Fuzzing and Trivia"/><published>2022-12-04T15:16:31+00:00</published><updated>2022-12-04T15:16:31+00:00</updated><id>https://yuxqiu.github.io/blog/2022/til-5</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/til-5/"><![CDATA[<h2 id="java-singleton">Java Singleton</h2> <p>A traditional way of creating Singleton is like this:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(){}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>To ensure thread safety, we can add synchronized to the <code class="language-plaintext highlighter-rouge">get</code> method:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">Singleton</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>However, this method is very inefficient as it requires us to acquire a lock every time we want to access the object.</p> <p>The solution is to use double checking, which allows us to acquire the lock only when we initialize the object at the first time.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="fuzzing-in-c-and-java">Fuzzing in C and Java</h2> <p>A classic fuzzing setup in C++ with libFuzzer:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">LLVMFuzzerTestOneInput</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">Data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomethingInterestingWithMyAPI</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">Size</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Values other than 0 and -1 are reserved for future use.</span>
<span class="p">}</span>
</code></pre></div></div> <p>To use it, use the <code class="language-plaintext highlighter-rouge">-fsanitize=fuzzer</code> flag during the compilation and linking. Typically, we use fuzzing together with <code class="language-plaintext highlighter-rouge">ASAN</code> and <code class="language-plaintext highlighter-rouge">UBSAN</code>.</p> <p>If your function doesn’t take <code class="language-plaintext highlighter-rouge">uint8_t *</code> directly, you may find it useful to use <a href="https://github.com/lefticus/cpp_weekly/issues/181">Jason Turner’s template for fuzzing</a>. A more detailed guide of libFuzzer can be found at <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer – a library for coverage-guided fuzz testing</a>.</p> <hr/> <p>In Java, I have only used <a href="https://github.com/CodeIntelligenceTesting/jazzer">Jazzer</a> in one of my recent projects. The advantages of Jazzer is that you can use it with jUnit (with maven).</p> <p>The repository has a detailed guideline about how to use it. I will present how to use it with jUnit (with limited capability but enough for us).</p> <ol> <li>Go to their <a href="https://github.com/CodeIntelligenceTesting/jazzer/tree/main/examples/junit">jUnit Example</a></li> <li>Make sure add all the dependencies to your <code class="language-plaintext highlighter-rouge">pom.xml</code></li> <li> <p>Create your tests that use the following templates:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// If you only want to use byte[]</span>
 <span class="kn">import</span> <span class="nn">com.code_intelligence.jazzer.junit.FuzzTest</span><span class="o">;</span>

 <span class="kd">class</span> <span class="nc">ByteFuzzTest</span> <span class="o">{</span>
     <span class="nd">@FuzzTest</span>
     <span class="kt">void</span> <span class="nf">byteFuzz</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="c1">// If you want to deal with some complicated data types</span>
 <span class="c1">// you can generate int/boolean/String... from FuzzedDataProvider</span>
 <span class="kn">import</span> <span class="nn">com.code_intelligence.jazzer.api.FuzzedDataProvider</span><span class="o">;</span>

 <span class="kd">class</span> <span class="nc">CustomFuzzTest</span> <span class="o">{</span>
     <span class="nd">@FuzzTest</span>
     <span class="kt">void</span> <span class="nf">customFuzz</span><span class="o">(</span><span class="nc">FuzzDataProvider</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div> </div> </li> <li>As fuzzing takes time to run, you can also specify how long to run these fuzzing with <code class="language-plaintext highlighter-rouge">@FuzzTest(maxDuration = "5m")</code>. (The default value is 5 minutes)</li> <li>Somethings about the test <ol> <li>You need to set environment variable <code class="language-plaintext highlighter-rouge">JAZZER_FUZZ</code> to any non-empty value; otherwise, only empty input will be given to your function.</li> <li>“When an assertion in the test fails, an exception is thrown but not caught, or Jazzer’s instrumentation detects a security issue (e.g. SQL injection or insecure deserialization), the fuzz test is reported as failed and the input is collected in the inputs directory for the test class.”</li> <li>Only a single fuzz test per test run will be executed in fuzzing mode. All other fuzz tests will be skipped. <ol> <li>This means if you want to run all the fuzzing tests inside some packages, you need to run them one by one.</li> </ol> </li> </ol> </li> </ol> <h2 id="10-core-guidelines-for-c">10 core guidelines for C++</h2> <blockquote> <p><a href="https://www.youtube.com/watch?v=XkDEzfpdcSg">CppCon 2017: Kate Gregory “10 Core Guidelines You Need to Start Using Now”</a></p> </blockquote> <ol> <li> <p>Prefer default argument rather than overloading</p> </li> <li>Initialization order is the order the var is defined <ol> <li>So, to avoid confusion, we need to use the same order in constructor</li> <li>Even if we declare them in different order, they are actually evaluated in the order in which the member variables are defined</li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">std::tie</code> and <code class="language-plaintext highlighter-rouge">std::ignore</code> <ol> <li><code class="language-plaintext highlighter-rouge">std::tie</code> creates a tuple of references</li> <li>we can use this to bind a returned tuple to some of the existing variable</li> <li><code class="language-plaintext highlighter-rouge">std::ignore</code> can be used with <code class="language-plaintext highlighter-rouge">std::tie</code> to let us ignore some variables</li> </ol> </li> </ol> <h2 id="trivia">Trivia</h2> <ol> <li><code class="language-plaintext highlighter-rouge">std::nextafter</code> <ol> <li>Useful if we want to get the next value of <code class="language-plaintext highlighter-rouge">float/double/long double</code></li> <li><a href="https://www.youtube.com/watch?v=-F0j2VN4xEU">C++ Weekly - Ep 223 - Know Your Standard Library: std::nextafter</a></li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code> <ol> <li>Useful when we need to 1) acquire a lock and 2) do some recursions in that function</li> <li>Solutions without <code class="language-plaintext highlighter-rouge">recursive_mutex</code> is to create a entry function and do locking in it. Check <a href="https://stackoverflow.com/a/2415088">this answer</a>.</li> </ol> </li> <li>Inefficient placement new before C++17 <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <ol> <li>For any version of gcc without -std=c++17 or -std=c++1z, any version of clang below 3.4 (January 2014)</li> <li>Placement new will perform a null pointer check on the memory passed in. If null is passed in: the returned object is also null</li> <li>Marc Glisse/Jonathan Wakely (wg21.link/cwg1748) clarified this in 2013: Passing null to placement new is now Undefined Behaviour [5.3.4.15]</li> </ol> </li> <li>Profilers <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <ol> <li>I have talked about profilers <a href="/blog/2022/pprof/">before</a>. This is an example of sampling profiler. The main drawbacks they have is that “they miss the key events”.</li> <li>There are some other profilers like: Instrumentation profilers (e.g. callgrind) <ol> <li>They are too intrusive</li> <li>They don’t catch I/O slowness/jitter</li> </ol> </li> </ol> </li> </ol> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.youtube.com/watch?v=NH1Tta7purM">CppCon 2017: Carl Cook “When a Microsecond Is an Eternity: High Performance Trading Systems in C++</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="TIL"/><category term="cpp"/><category term="java"/><summary type="html"><![CDATA[Java Singleton]]></summary></entry><entry><title type="html">TIL-4: Alignment</title><link href="https://yuxqiu.github.io/blog/2022/til-4/" rel="alternate" type="text/html" title="TIL-4: Alignment"/><published>2022-12-03T14:24:29+00:00</published><updated>2022-12-03T14:24:29+00:00</updated><id>https://yuxqiu.github.io/blog/2022/til-4</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/til-4/"><![CDATA[<h2 id="alignment-and-cache">Alignment and Cache</h2> <ol> <li> <p>Common cache line size is 64 bytes</p> </li> <li> <p>To ensure data in different thread doesn’t interfere with other due to the requirement of cache consistency, we need to make sure they operate on data that is on different cache lines</p> </li> <li>C++ provides us with keyword <code class="language-plaintext highlighter-rouge">alignas</code> <ol> <li><code class="language-plaintext highlighter-rouge">alignas</code> can be used to 1) the declaration or definition of a class; 2) the declaration of a non-bitfield class data member; 3) the declaration of a variable, except that it cannot be applied to the following: a function parameter; the exception parameter of a catch clause.</li> <li>Example: <code class="language-plaintext highlighter-rouge">struct alignas(32) sse_t { ... };</code> or <code class="language-plaintext highlighter-rouge">alignas(64) int x;</code> or <code class="language-plaintext highlighter-rouge">int alignas(64) x;</code></li> </ol> </li> <li>C++ also provide <code class="language-plaintext highlighter-rouge">hardware_destructive_interference_size</code> and <code class="language-plaintext highlighter-rouge">hardware_constructive_interference_size</code> in <code class="language-plaintext highlighter-rouge">&lt;new&gt;</code>. According to cppreference, “these constants provide a portable way to access the L1 data cache line size.” <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <ol> <li><code class="language-plaintext highlighter-rouge">hardware_destructive_interference_size</code> defines “minimum offset between two objects to avoid false sharing.”</li> <li> <p><code class="language-plaintext highlighter-rouge">hardware_constructive_interference_size</code> defines “maximum size of contiguous memory to promote true sharing.”</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// occupies one cache line</span>
  <span class="k">struct</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">hardware_constructive_interference_size</span><span class="p">)</span> <span class="n">OneCacheLiner</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">atomic_uint64_t</span> <span class="n">x</span><span class="p">{};</span>
      <span class="n">std</span><span class="o">::</span><span class="n">atomic_uint64_t</span> <span class="n">y</span><span class="p">{};</span>
  <span class="p">};</span>

  <span class="c1">// occupies two cache lines</span>
  <span class="k">struct</span> <span class="nc">TwoCacheLiner</span> <span class="p">{</span>
      <span class="k">alignas</span><span class="p">(</span><span class="n">hardware_destructive_interference_size</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_uint64_t</span> <span class="n">x</span><span class="p">{};</span>
      <span class="k">alignas</span><span class="p">(</span><span class="n">hardware_destructive_interference_size</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_uint64_t</span> <span class="n">y</span><span class="p">{};</span>
  <span class="p">}</span> <span class="n">twoCacheLiner</span><span class="p">;</span>
</code></pre></div> </div> </li> </ol> </li> <li>What exactly is <a href="https://en.cppreference.com/w/cpp/language/object#Alignment">alignment</a>? <ol> <li>“The number of bytes between successive addresses at which objects of this type can be allocated”</li> <li>“Each object type imposes its alignment requirement on every object of that type;”</li> <li>“The largest fundamental alignment of any type is implementation-defined and equal to the alignment of <code class="language-plaintext highlighter-rouge">std::max_align_t</code>” (which is the size of <code class="language-plaintext highlighter-rouge">long double</code> 16 bytes)</li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">alignof</code> <ol> <li>Like <code class="language-plaintext highlighter-rouge">sizeof</code>, but returned the alignment of the object</li> </ol> </li> </ol> <h2 id="trivia">Trivia</h2> <ol> <li> <p>Shell command starts with spaces can hide this command from history</p> </li> <li>A simplified evaluation order of shell (This is derived from one of our recent projects: Develop a Shell in Java) <ol> <li>Command substitution is performed (see command substitution);</li> <li>The command is split into arguments based on whitespaces</li> <li>Globbing is performed</li> <li>The application is called</li> </ol> </li> <li>Commonly used shortcuts for oh-my-zsh <code class="language-plaintext highlighter-rouge">git</code> plugin <ol> <li><a href="https://kapeli.com/cheat_sheets/Oh-My-Zsh_Git.docset/Contents/Resources/Documents/index">Cheatsheet</a></li> <li><code class="language-plaintext highlighter-rouge">ga = git add</code>, <code class="language-plaintext highlighter-rouge">gaa = git add -all</code></li> <li><code class="language-plaintext highlighter-rouge">gb = git branch</code>, <code class="language-plaintext highlighter-rouge">gbd = git branch -d</code>, <code class="language-plaintext highlighter-rouge">gbD = git branch -D</code></li> <li><code class="language-plaintext highlighter-rouge">gcb = git checkout -b</code>, <code class="language-plaintext highlighter-rouge">gco = git checkout</code>, <code class="language-plaintext highlighter-rouge">gd = git diff</code></li> <li><code class="language-plaintext highlighter-rouge">gf = git fetch</code>, <code class="language-plaintext highlighter-rouge">gfo = git fetch origin</code></li> <li><code class="language-plaintext highlighter-rouge">gl = git pull</code></li> <li><code class="language-plaintext highlighter-rouge">gp = git push</code>, <code class="language-plaintext highlighter-rouge">gpf = git push --force-with-lease</code>, <code class="language-plaintext highlighter-rouge">gpf! = git push --force</code></li> <li><code class="language-plaintext highlighter-rouge">gm = git merge</code></li> <li><code class="language-plaintext highlighter-rouge">gr = git remote</code>, <code class="language-plaintext highlighter-rouge">gra = git remote add</code></li> <li><code class="language-plaintext highlighter-rouge">grb = git rebase</code>, <code class="language-plaintext highlighter-rouge">grba = git rebase --abort</code>, <code class="language-plaintext highlighter-rouge">grbc = git rebase --continue</code>, <code class="language-plaintext highlighter-rouge">grbi = git rebase -i</code></li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">git reset</code> different levels (<code class="language-plaintext highlighter-rouge">soft</code>, <code class="language-plaintext highlighter-rouge">mixed</code>, <code class="language-plaintext highlighter-rouge">hard</code>) <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> <ol> <li><img src="https://i.stack.imgur.com/qRAte.jpg" alt="Visualization of git reset different levels"/></li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">time</code> command <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> <ol> <li>Real is wall clock time - time from start to finish of the call. This is all elapsed time including time slices used by other processes and time the process spends blocked (for example if it is waiting for I/O to complete).</li> <li>User is the amount of CPU time spent in user-mode code (outside the kernel) within the process. This is only actual CPU time used in executing the process. Other processes and time the process spends blocked do not count towards this figure.</li> <li>Sys is the amount of CPU time spent in the kernel within the process. This means executing CPU time spent in system calls within the kernel, as opposed to library code, which is still running in user-space. Like ‘user’, this is only CPU time used by the process.</li> </ol> </li> </ol> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size">cppreference std::hardware_destructive_interference_size, std::hardware_constructive_interference_size</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="https://stackoverflow.com/a/3528483">mkarasek’s answer: What’s the difference between git reset --mixed, --soft, and --hard?</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p><a href="http://zch051383471952.blogspot.com/2010/01/different-of-real-user-sys-time.html">DIFFERENT OF REAL USER SYS TIME</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="TIL"/><category term="cpp"/><summary type="html"><![CDATA[Alignment and Cache]]></summary></entry><entry><title type="html">TIL-3: final, Small Integer operations, vector</title><link href="https://yuxqiu.github.io/blog/2022/til-3/" rel="alternate" type="text/html" title="TIL-3: final, Small Integer operations, vector"/><published>2022-11-17T23:28:26+00:00</published><updated>2022-11-17T23:28:26+00:00</updated><id>https://yuxqiu.github.io/blog/2022/til-3</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/til-3/"><![CDATA[<h2 id="final">final</h2> <ol> <li>final is a way to forbid you overriding a virtual function again <ol> <li>It should not be used with <code class="language-plaintext highlighter-rouge">override</code> as it implies override</li> </ol> </li> <li>final allows compilers to do optimization<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li> </ol> <h2 id="base-virtual-destructor">Base virtual destructor</h2> <ol> <li>Base virtual destructor implies children virtual destructor, so we can use rule of 0 here.</li> </ol> <h2 id="small-integer-operations-">Small Integer Operations <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2> <ol> <li>When doing arithmetic operations on small unsigned integers (those with rank less than <code class="language-plaintext highlighter-rouge">int</code>), they will be promoted to int <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> <ol> <li>the deducted return type with <code class="language-plaintext highlighter-rouge">auto</code> will become int</li> <li>any further operations on this value (e.g. right shift) are operating on int, which can yield unexpected impact</li> </ol> </li> <li>To solve this problem, when doing arithmetic operations on small unsigned integer, we need to use <code class="language-plaintext highlighter-rouge">static_cast</code> to change their type back to the original unsigned type</li> </ol> <h2 id="weird-vector-bool-">Weird vector bool <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></h2> <ol> <li>C++ standard “recommends” a space-optimized specialization of <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;</code> <ol> <li>This optimization works by actually placing bool inside a bit</li> </ol> </li> <li>However, if we need to access the member inside the list, the <code class="language-plaintext highlighter-rouge">operator[]</code> returns a proxy object for us <ol> <li>that allows us to view/change the value</li> </ol> </li> <li>But the proxy project cannot be bound to lvalue reference <code class="language-plaintext highlighter-rouge">auto &amp;</code> while other instantiation of vector all allow you to <code class="language-plaintext highlighter-rouge">auto &amp;ref = v[idx]</code> <ol> <li>To store the proxy object, you need to use <code class="language-plaintext highlighter-rouge">auto sth = v[idx]</code></li> <li>If you want to use bit field by yourself, you cannot bind the member by reference either</li> </ol> </li> </ol> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Compilers are allowed to call function directly instead of following vtable. See <a href="https://stackoverflow.com/a/17604779">this answer</a> for more details. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>See Jason Turner’s video <a href="https://www.youtube.com/watch?v=R6_PFqOSa_c">C++ Weekly - Ep 310 - Your Small Integer Operations Are Broken!</a> for more details. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>cppreference provides <a href="https://en.cppreference.com/w/c/language/conversion">a detailed explanation</a> about arithmetic conversions and integer promotions <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>See Jason Turner’s video <a href="https://www.youtube.com/watch?v=OP9IDIeicZE">C++ Weekly - Ep 325 - Why vector of bool is Weird</a> for more details. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="TIL"/><category term="cpp"/><summary type="html"><![CDATA[final]]></summary></entry><entry><title type="html">TIL-2: C++ Best Practices, Initializer List, Extern Template</title><link href="https://yuxqiu.github.io/blog/2022/til-2/" rel="alternate" type="text/html" title="TIL-2: C++ Best Practices, Initializer List, Extern Template"/><published>2022-11-16T21:27:32+00:00</published><updated>2022-11-16T21:27:32+00:00</updated><id>https://yuxqiu.github.io/blog/2022/til-2</id><content type="html" xml:base="https://yuxqiu.github.io/blog/2022/til-2/"><![CDATA[<h2 id="compiler-warnings">Compiler Warnings</h2> <ol> <li>Something I don’t know about: <code class="language-plaintext highlighter-rouge">Wpedantic</code> disables language extension <ol> <li>which is good</li> </ol> </li> </ol> <h2 id="range-based-for-loop">Range-based for loop</h2> <ol> <li><code class="language-plaintext highlighter-rouge">const auto &amp;</code> in most cases</li> <li><code class="language-plaintext highlighter-rouge">auto &amp;</code> if you need to modify the element inside the container</li> <li><code class="language-plaintext highlighter-rouge">auto &amp;&amp;</code> if moving elements out of the container</li> </ol> <h2 id="template">Template</h2> <ol> <li>Don’t use <code class="language-plaintext highlighter-rouge">Type T</code> for template. Use some meaningful names (like <code class="language-plaintext highlighter-rouge">BinaryPred</code>, <code class="language-plaintext highlighter-rouge">UnaryPred</code>)</li> </ol> <h2 id="inheritance">Inheritance</h2> <ol> <li>In most cases, delete 4 special members (except constructor, destructor) when you use inheritance because it’s hard to define a correct copy/move constructor and assignment <ol> <li>If there is no slicing issue, you could try default them</li> </ol> </li> </ol> <h2 id="undefined-behavior">Undefined Behavior</h2> <ol> <li>Compilers are allowed to assume no undefined behavior happens in your code <ol> <li>So, sometimes, your code will be optimized out because of this reason</li> <li>In case this happens, it really means you are relying on UB</li> </ol> </li> <li>Checking <code class="language-plaintext highlighter-rouge">reference == nullptr</code> is undefined behavior</li> <li>Dereferencing nullptr is also undefined behavior</li> </ol> <h2 id="switch">switch</h2> <ol> <li>Don’t use <code class="language-plaintext highlighter-rouge">default</code> in <code class="language-plaintext highlighter-rouge">switch</code> <ol> <li>We are talking about using switch with enum</li> <li>This rule applies to C</li> <li>Because if we add new options, default will disable us to get warning about the missing cases</li> </ol> </li> </ol> <h2 id="const-everywhere">const everywhere</h2> <ol> <li><code class="language-plaintext highlighter-rouge">const</code> as much as you can as soon as it doesn’t affect implicit move</li> <li> <p>If you need to modify code, you can use immediately-invoked lambda <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">const</span> <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
     <span class="c1">// modification here</span>
     <span class="c1">// NRVO (very likely)</span>
     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}();</span>
</code></pre></div> </div> </li> </ol> <h2 id="exception-handling-">Exception Handling <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2> <ol> <li>Lippincott exception handling <ol> <li>A centralized way to deal with exception</li> </ol> </li> <li>Basically, catch all the exception with <code class="language-plaintext highlighter-rouge">catch(...)</code> <ol> <li>Inside the catch block, call <code class="language-plaintext highlighter-rouge">lippincott</code></li> </ol> </li> <li>This <code class="language-plaintext highlighter-rouge">lippincott</code> function tries to rethrow the error with <code class="language-plaintext highlighter-rouge">throw;</code> inside a try block with many possible catches <ol> <li>If any of them matches, we process that particular exception</li> <li>If this function is called without any exception, <code class="language-plaintext highlighter-rouge">std::terminate</code> is called</li> </ol> </li> </ol> <h2 id="make-your-interface-hard-to-use-incorrectly">Make your interface hard to use incorrectly</h2> <blockquote> <p>Effective C++ item 18: Make interfaces easy to use correctly and hard to use incorrectly</p> </blockquote> <ol> <li>Even though your data might be easy (just a int or bool or …), it’s still necessary for you to create a wrapper for it to tell people explicitly what’s the meaning of the code. <ol> <li>Then, it’s hard for people to use your interface incorrectly</li> </ol> </li> <li>Any function or overload can be <code class="language-plaintext highlighter-rouge">=deleted</code> in C++11 <ol> <li>This disables people pass parameters that could implicitly convert to our specified types unexpectedly. For example, if we want to accept double and reject float, we delete the overload for float.</li> </ol> </li> </ol> <h2 id="dont-use-initializer_list-for-non-trivial-types">Don’t Use initializer_list For Non-Trivial Types</h2> <blockquote> <p>Talk: <a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">C++Now 2018: Jason Turner “Initializer Lists Are Broken, Let’s Fix Them”</a></p> <p>Slide: <a href="https://github.com/boostcon/cppnow_presentations_2018/blob/master/05-09-2018_wednesday/initializer_lists_are_broken__jason_turner__cppnow_05092018.pdf">initializer_lists Are Broken, Let’s Fix Them</a></p> </blockquote> <ol> <li><code class="language-plaintext highlighter-rouge">std::initializer_lists&lt;T&gt;</code> is like a view instead of a concrete container that actually controls the lifetime of the object <ol> <li>It’s a pointer to an local array</li> <li>“An object of type <code class="language-plaintext highlighter-rouge">std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation generated and materialized a prvalue of type “array of N const E”, where N is the number of elements in the initializer list. Each element of that array is copy initialized with the corresponding element of the initializer list, and the <code class="language-plaintext highlighter-rouge">std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array”</li> <li>So, returning an initializer_list from a function is like returning a pointer to a local object</li> </ol> </li> <li>Because the generated array is const, we can only use copy constructor when using initializer_list <ol> <li>This causes us fail to construct a vector of unique_ptr via initializer_list</li> <li> <p>But, we can still construct an array via initializer list because this is aggregate initialization instead of initializer_list</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
     <span class="n">X</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
 <span class="p">};</span>
 <span class="n">X</span> <span class="n">x</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span> <span class="p">};</span>

 <span class="c1">// is equivalent to</span>
 <span class="k">const</span> <span class="kt">double</span> <span class="n">__a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="kt">double</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="kt">double</span><span class="p">{</span><span class="mi">2</span><span class="p">},</span> <span class="kt">double</span><span class="p">{</span><span class="mi">3</span><span class="p">}};</span>
 <span class="n">X</span> <span class="nf">x</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__a</span><span class="p">,</span> <span class="n">__a</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span>
</code></pre></div> </div> </li> <li>No narrowing conversions allowed because we are initializing the member via <code class="language-plaintext highlighter-rouge">{}</code></li> </ol> </li> <li>Possible Improvements <ol> <li>A non-const array with movable iterator <ol> <li>check <code class="language-plaintext highlighter-rouge">std::make_move_iterator</code></li> </ol> </li> <li>Construct in-place by inheriting from vector</li> </ol> </li> <li>Interesting Observations <ol> <li>Compilers may not have the ability to track the size of <code class="language-plaintext highlighter-rouge">const char *</code>. To have a higher probability of doing SSO, construct the string directly when trying to return <code class="language-plaintext highlighter-rouge">const char *</code> from functions and later try to construct a string with this <code class="language-plaintext highlighter-rouge">const char *</code></li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">std::in_place_t</code> <ol> <li>A tag used by <code class="language-plaintext highlighter-rouge">variant</code>, <code class="language-plaintext highlighter-rouge">optional</code> and <code class="language-plaintext highlighter-rouge">any</code> so that we can default construct the actual object in-place. These types could be non-movable/non-copyable.</li> <li><code class="language-plaintext highlighter-rouge">std::make_optional</code>, <code class="language-plaintext highlighter-rouge">std::make_any</code>, <code class="language-plaintext highlighter-rouge">std::in_place</code> (the global value that has type <code class="language-plaintext highlighter-rouge">std::in_place_t</code>), <code class="language-plaintext highlighter-rouge">std::in_place_type&lt;T&gt;</code> (useful when trying to decide which type in variant to init), <code class="language-plaintext highlighter-rouge">std::in_place_index&lt;val&gt;</code> (specify which index to create/set)</li> <li>See <a href="https://www.cppstories.com/2018/07/in-place-cpp17/">this article</a> for more details</li> </ol> </li> </ol> <h2 id="extern-template-">Extern Template <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></h2> <ol> <li>If we use one template with a specific type frequently, extern template can help us solve the time to instantiate the template in each translational unit <ol> <li>In the normal process, template is initialized in every translational unit if it’s used and during link time, only one instantiation will be kept.</li> </ol> </li> <li>By using <code class="language-plaintext highlighter-rouge">extern template void Fun&lt;T&gt;();</code>, we signify that we have a template already instantiated. <ol> <li>Put this declaration in header file to make sure when we compile this code with <code class="language-plaintext highlighter-rouge">-O3</code>, the instantiated template is not inlined.</li> </ol> </li> </ol> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>You can check Jason Turner’s channel <a href="https://www.youtube.com/watch?v=d4nmNYTM1j8">C++ Weekly - Ep 70 - C++ IIFE in quick-bench.com</a> for more information about IIFE (immediately-invoked function expression) <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="http://cppsecrets.blogspot.com/2013/12/using-lippincott-function-for.html">Using a Lippincott Function for Centralized Exception Handling</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p><a href="https://arne-mertz.de/2019/02/extern-template-reduce-compile-times/">Reduce Compilation Times With extern template</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="TIL"/><category term="cpp"/><summary type="html"><![CDATA[Compiler Warnings]]></summary></entry></feed>